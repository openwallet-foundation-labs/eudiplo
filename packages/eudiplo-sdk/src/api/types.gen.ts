// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: string;
};

export type EcPublic = {
  /**
   * The key type, which is always 'EC' for Elliptic Curve keys.
   */
  kty: string;
  /**
   * The algorithm intended for use with the key, such as 'ES256'.
   */
  crv: string;
  /**
   * The x coordinate of the EC public key.
   */
  x: string;
  /**
   * The y coordinate of the EC public key.
   */
  y: string;
};

export type JwksResponseDto = {
  /**
   * An array of EC public keys in JWK format.
   */
  keys: Array<EcPublic>;
};

export type RoleDto = {
  /**
   * OAuth2 roles
   */
  role:
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage";
};

export type ClientCredentialsDto = {
  client_id: string;
  client_secret: string;
};

export type TokenResponse = {
  access_token: string;
  refresh_token?: string;
  token_type: string;
  expires_in: number;
};

export type TenantEntity = {
  /**
   * The unique identifier for the tenant.
   */
  id: string;
  /**
   * The name of the tenant.
   */
  name: string;
  /**
   * The description of the tenant.
   */
  description?: string;
  /**
   * The current status of the tenant.
   */
  status: string;
  /**
   * The clients associated with the tenant.
   */
  clients: Array<ClientEntity>;
};

export type ClientEntity = {
  /**
   * The unique identifier for the client.
   */
  clientId: string;
  /**
   * The secret key for the client.
   */
  secret?: string;
  /**
   * The unique identifier for the tenant that the client belongs to. Only null for accounts that manage tenants, that do not belong to a client
   */
  tenantId?: string;
  /**
   * The description of the client.
   */
  description?: string;
  /**
   * The roles assigned to the client.
   */
  roles: Array<
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage"
  >;
  /**
   * The tenant that the client belongs to.
   */
  tenant?: TenantEntity;
};

export type CreateTenantDto = {
  roles?: Array<
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage"
  >;
  /**
   * The unique identifier for the tenant.
   */
  id: string;
  /**
   * The name of the tenant.
   */
  name: string;
  /**
   * The description of the tenant.
   */
  description?: string;
};

export type ClientSecretResponseDto = {
  secret: string;
};

export type UpdateClientDto = {
  /**
   * The description of the client.
   */
  description?: string;
  /**
   * The roles assigned to the client.
   */
  roles: Array<
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage"
  >;
};

export type CreateClientDto = {
  /**
   * The unique identifier for the client.
   */
  clientId: string;
  /**
   * The description of the client.
   */
  description?: string;
  /**
   * The roles assigned to the client.
   */
  roles: Array<
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage"
  >;
};

export type KeyEntity = {
  /**
   * Unique identifier for the key.
   */
  id: string;
  /**
   * Description of the key.
   */
  description?: string;
  /**
   * Tenant ID for the key.
   */
  tenantId: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  /**
   * The key material.
   */
  key: {
    [key: string]: unknown;
  };
  /**
   * The usage type of the key.
   */
  usage: {
    [key: string]: unknown;
  };
  /**
   * Certificates associated with this key.
   */
  certificates: Array<CertEntity>;
  /**
   * The timestamp when the key was created.
   */
  createdAt: string;
  /**
   * The timestamp when the key was last updated.
   */
  updatedAt: string;
};

export type CertEntity = {
  /**
   * Certificate can be used for access/authentication
   */
  isAccessCert: boolean;
  /**
   * Certificate can be used for signing
   */
  isSigningCert: boolean;
  /**
   * The key ID this certificate is associated with
   */
  keyId: string;
  /**
   * Unique identifier for the key.
   */
  id: string;
  /**
   * Tenant ID for the key.
   */
  tenantId: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  /**
   * Certificate in PEM format.
   */
  crt: string;
  /**
   * Description of the key.
   */
  description?: string;
  key: KeyEntity;
  /**
   * The timestamp when the certificate was created.
   */
  createdAt: string;
  /**
   * The timestamp when the certificate was last updated.
   */
  updatedAt: string;
};

export type Key = {
  kty: string;
  x: string;
  y: string;
  crv: string;
  d: string;
  alg: string;
};

export type KeyImportDto = {
  /**
   * The private key in JWK format.
   */
  key: Key;
  /**
   * Unique identifier for the key.
   */
  id: string;
  /**
   * Description of the key.
   */
  description?: string;
};

export type UpdateKeyDto = {
  /**
   * Unique identifier for the key.
   */
  id: string;
  /**
   * Description of the key.
   */
  description?: string;
};

export type CertImportDto = {
  /**
   * Certificate can be used for access/authentication
   */
  isAccessCert: boolean;
  /**
   * Certificate can be used for signing
   */
  isSigningCert: boolean;
  /**
   * The key ID this certificate is associated with
   */
  keyId: string;
  /**
   * Unique identifier for the key.
   */
  id: string;
  /**
   * Certificate in PEM format.
   */
  crt: string;
  /**
   * Description of the key.
   */
  description?: string;
};

export type CertResponseDto = {
  /**
   * The ID of the created self-signed certificate.
   */
  id: string;
};

export type CertSelfSignedDto = {
  /**
   * Certificate can be used for access/authentication
   */
  isAccessCert: boolean;
  /**
   * Certificate can be used for signing
   */
  isSigningCert: boolean;
  /**
   * The key ID this certificate is associated with
   */
  keyId: string;
};

export type CertUpdateDto = {
  /**
   * Certificate can be used for access/authentication
   */
  isAccessCert: boolean;
  /**
   * Certificate can be used for signing
   */
  isSigningCert: boolean;
  /**
   * Description of the key.
   */
  description?: string;
};

export type WebHookAuthConfigNone = {
  /**
   * The type of authentication used for the webhook.
   */
  type: "none";
};

export type ApiKeyConfig = {
  /**
   * The name of the header where the API key will be sent.
   */
  headerName: string;
  /**
   * The value of the API key to be sent in the header.
   */
  value: string;
};

export type WebHookAuthConfigHeader = {
  /**
   * The type of authentication used for the webhook.
   */
  type: "apiKey";
  /**
   * Configuration for API key authentication.
   * This is required if the type is 'apiKey'.
   */
  config: ApiKeyConfig;
};

export type WebhookConfig = {
  /**
   * Optional authentication configuration for the webhook.
   * If not provided, no authentication will be used.
   */
  auth: WebHookAuthConfigNone | WebHookAuthConfigHeader;
  /**
   * The URL to which the webhook will send notifications.
   */
  url: string;
};

export type PresentationRequest = {
  /**
   * The type of response expected from the presentation request.
   */
  response_type: "qrcode" | "uri" | "dc-api";
  /**
   * Identifier of the presentation configuration
   */
  requestId: string;
  /**
   * Webhook configuration to receive the response.
   * If not provided, the configured webhook from the configuration will be used.
   */
  webhook?: WebhookConfig;
  /**
   * Optional redirect URI to which the user-agent should be redirected after the presentation is completed.
   */
  redirectUri?: string;
};

export type OfferResponse = {
  uri: string;
  session: string;
};

export type Claim = {
  path: Array<string>;
};

export type TrustedAuthorityQuery = {
  type: "aki" | "etsi_tl" | "openid_federation";
  values: Array<string>;
};

export type CredentialQuery = {
  id: string;
  format: string;
  multiple?: boolean;
  claims?: Array<Claim>;
  meta: {
    [key: string]: unknown;
  };
  trusted_authorities?: Array<TrustedAuthorityQuery>;
};

export type CredentialSetQuery = {
  options: Array<Array<string>>;
  required?: boolean;
};

export type Dcql = {
  credentials: Array<CredentialQuery>;
  credential_set?: Array<CredentialSetQuery>;
};

export type RegistrationCertificateRequest = {
  /**
   * Identifier of the registration certificate that got issued.
   */
  id?: string;
  /**
   * The body of the registration certificate request containing the necessary details.
   */
  body: {
    [key: string]: unknown;
  };
};

export type PresentationAttachment = {
  format: string;
  data: {
    [key: string]: unknown;
  };
  credential_ids?: Array<string>;
};

export type PresentationConfig = {
  /**
   * Unique identifier for the VP request.
   */
  id: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  /**
   * Description of the presentation configuration.
   */
  description?: string;
  /**
   * Lifetime how long the presentation request is valid after creation, in seconds.
   */
  lifeTime?: number;
  /**
   * The DCQL query to be used for the VP request.
   */
  dcql_query: Dcql;
  /**
   * The registration certificate request containing the necessary details.
   */
  registrationCert?: RegistrationCertificateRequest;
  /**
   * Optional webhook URL to receive the response.
   */
  webhook?: WebhookConfig;
  /**
   * The timestamp when the VP request was created.
   */
  createdAt: string;
  /**
   * The timestamp when the VP request was last updated.
   */
  updatedAt: string;
  /**
   * Attestation that should be attached
   */
  attached?: Array<PresentationAttachment>;
  /**
   * Redirect URI to which the user-agent should be redirected after the presentation is completed.
   */
  redirectUri?: string;
};

export type PresentationConfigCreateDto = {
  /**
   * Unique identifier for the VP request.
   */
  id: string;
  /**
   * Description of the presentation configuration.
   */
  description?: string;
  /**
   * Lifetime how long the presentation request is valid after creation, in seconds.
   */
  lifeTime?: number;
  /**
   * The DCQL query to be used for the VP request.
   */
  dcql_query: Dcql;
  /**
   * The registration certificate request containing the necessary details.
   */
  registrationCert?: RegistrationCertificateRequest;
  /**
   * Optional webhook URL to receive the response.
   */
  webhook?: WebhookConfig;
  /**
   * Attestation that should be attached
   */
  attached?: Array<PresentationAttachment>;
  /**
   * Redirect URI to which the user-agent should be redirected after the presentation is completed.
   */
  redirectUri?: string;
};

export type AuthorizeQueries = {
  issuer_state?: string;
  response_type?: string;
  client_id?: string;
  redirect_uri?: string;
  resource?: string;
  scope?: string;
  code_challenge?: string;
  code_challenge_method?: string;
  dpop_jkt?: string;
  request_uri?: string;
  auth_session?: string;
  state?: string;
};

export type OfferRequestDto = {
  /**
   * The type of response expected for the offer request.
   */
  response_type: "qrcode" | "uri" | "dc-api";
  /**
   * The flow type for the offer request.
   */
  flow: "authorization_code" | "pre_authorized_code";
  /**
   * Transaction code for pre-authorized code flow.
   */
  tx_code?: string;
  /**
   * List of credential configuration ids to be included in the offer.
   */
  credentialConfigurationIds: Array<string>;
  /**
   * Credential claims configuration per credential.
   * Each credential can have claims provided inline or fetched via webhook.
   */
  credentialClaims?: {
    [key: string]: unknown;
  };
  /**
   * Webhook to notify about the status of the issuance process.
   */
  notifyWebhook?: WebhookConfig;
};

export type Session = {
  /**
   * Status of the session.
   */
  status: "active" | "fetched" | "completed" | "expired" | "failed";
  /**
   * Unique identifier for the session.
   */
  id: string;
  /**
   * The timestamp when the request was created.
   */
  createdAt: string;
  /**
   * The timestamp when the request was last updated.
   */
  updatedAt: string;
  /**
   * The timestamp when the request is set to expire.
   */
  expiresAt?: string;
  /**
   * Flag indicating whether to use the DC API for the presentation request.
   */
  useDcApi: boolean;
  /**
   * Tenant ID for multi-tenancy support.
   */
  tenantId: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  authorization_code?: string;
  /**
   * Request URI from the authorization request.
   */
  request_uri?: string;
  /**
   * Authorization queries associated with the session.
   */
  auth_queries?: AuthorizeQueries;
  /**
   * Credential offer object containing details about the credential offer or presentation request.
   */
  offer?: {
    [key: string]: unknown;
  };
  /**
   * Offer URL for the credential offer.
   */
  offerUrl?: string;
  /**
   * Credential payload containing the offer request details.
   */
  credentialPayload?: OfferRequestDto;
  /**
   * Webhook configuration to send the result of the notification response.
   */
  notifyWebhook?: WebhookConfig;
  /**
   * Notifications associated with the session.
   */
  notifications: Array<{
    [key: string]: unknown;
  }>;
  requestId?: string;
  /**
   * The URL of the presentation auth request.
   */
  requestUrl?: string;
  /**
   * Signed presentation auth request.
   */
  requestObject?: string;
  /**
   * Verified credentials from the presentation process.
   */
  credentials?: Array<{
    [key: string]: unknown;
  }>;
  /**
   * Noncce from the Verifiable Presentation request.
   */
  vp_nonce?: string;
  /**
   * Redirect URI to which the user-agent should be redirected after the presentation is completed.
   */
  redirectUri?: string;
  /**
   * Where to send the claims webhook response.
   */
  parsedWebhook?: WebhookConfig;
};

export type AuthorizationResponse = {
  /**
   * The response string containing the authorization details.
   */
  response: string;
  /**
   * When set to true, the authorization response will be sent to the client.
   */
  sendResponse?: boolean;
};

export type StatusUpdateDto = {
  /**
   * The session ID of the user
   */
  sessionId: string;
  /**
   * The ID of the credential configuration
   * This is optional, if not provided, all credentials will be revoked of the session.
   */
  credentialConfigurationId?: string;
  /**
   * The status of the credential
   * 0 = valid, 1 = revoked, 2 = suspended
   */
  status: number;
};

export type NotificationRequestDto = {
  notification_id: string;
  event: {
    [key: string]: unknown;
  };
};

export type ParResponseDto = {
  /**
   * The request URI for the Pushed Authorization Request.
   */
  request_uri: string;
  /**
   * The expiration time for the request URI in seconds.
   */
  expires_in: number;
};

export type ClaimsQuery = {
  id: string;
  path: Array<string>;
  values?: Array<{
    [key: string]: unknown;
  }>;
};

export type PolicyCredential = {
  claims?: Array<ClaimsQuery>;
  credentials: Array<CredentialQuery>;
  credential_sets?: Array<CredentialSetQuery>;
};

export type AttestationBasedPolicy = {
  policy: "attestationBased";
  values: Array<PolicyCredential>;
};

export type NoneTrustPolicy = {
  policy: "none";
};

export type AllowListPolicy = {
  policy: "allowList";
  values: Array<string>;
};

export type RootOfTrustPolicy = {
  policy: "rootOfTrust";
  values: string;
};

export type EmbeddedDisclosurePolicy = {
  policy: string;
};

export type DisplayImage = {
  uri: string;
};

export type Display = {
  name: string;
  description: string;
  locale: string;
  background_color?: string;
  text_color?: string;
  background_image?: DisplayImage;
  logo?: DisplayImage;
};

export type IssuerMetadataCredentialConfig = {
  format: string;
  display: Array<Display>;
  scope?: string;
};

export type Vct = {
  vct?: string;
  name?: string;
  description?: string;
  extends?: string;
  "extends#integrity"?: string;
  schema_uri?: string;
  "schema_uri#integrity"?: string;
};

export type SchemaResponse = {
  $schema: string;
  type: string;
  properties: {
    [key: string]: unknown;
  };
  required?: Array<string>;
  title?: string;
  description?: string;
};

export type CredentialConfig = {
  /**
   * Embedded disclosure policy (discriminated union by `policy`).
   * The discriminator makes class-transformer instantiate the right subclass,
   * and then class-validator runs that subclass’s rules.
   */
  embeddedDisclosurePolicy?: EmbeddedDisclosurePolicy;
  id: string;
  description?: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  config: IssuerMetadataCredentialConfig;
  claims?: {
    [key: string]: unknown;
  };
  /**
   * Webhook to receive claims for the issuance process.
   */
  claimsWebhook?: WebhookConfig;
  /**
   * Webhook to receive claims for the issuance process.
   */
  notificationWebhook?: WebhookConfig;
  disclosureFrame?: {
    [key: string]: unknown;
  };
  vct?: Vct;
  keyBinding?: boolean;
  certId?: string;
  cert: CertEntity;
  statusManagement?: boolean;
  lifeTime?: number;
  schema?: SchemaResponse;
};

export type CredentialConfigCreate = {
  /**
   * Embedded disclosure policy (discriminated union by `policy`).
   * The discriminator makes class-transformer instantiate the right subclass,
   * and then class-validator runs that subclass’s rules.
   */
  embeddedDisclosurePolicy?: EmbeddedDisclosurePolicy;
  id: string;
  description?: string;
  config: IssuerMetadataCredentialConfig;
  claims?: {
    [key: string]: unknown;
  };
  /**
   * Webhook to receive claims for the issuance process.
   */
  claimsWebhook?: WebhookConfig;
  /**
   * Webhook to receive claims for the issuance process.
   */
  notificationWebhook?: WebhookConfig;
  disclosureFrame?: {
    [key: string]: unknown;
  };
  vct?: Vct;
  keyBinding?: boolean;
  certId?: string;
  statusManagement?: boolean;
  lifeTime?: number;
  schema?: SchemaResponse;
};

export type AuthenticationMethodNone = {
  method: "none";
};

export type AuthenticationUrlConfig = {
  /**
   * The URL used in the OID4VCI authorized code flow.
   * This URL is where users will be redirected for authentication.
   */
  url: string;
  /**
   * Optional webhook configuration for authentication callbacks
   */
  webhook?: WebhookConfig;
};

export type AuthenticationMethodAuth = {
  method: "auth";
  config: AuthenticationUrlConfig;
};

export type PresentationDuringIssuanceConfig = {
  /**
   * Link to the presentation configuration that is relevant for the issuance process
   */
  type: string;
};

export type AuthenticationMethodPresentation = {
  method: "presentationDuringIssuance";
  config: PresentationDuringIssuanceConfig;
};

export type DisplayLogo = {
  uri: string;
  alt_text?: string;
};

export type DisplayInfo = {
  name?: string;
  locale?: string;
  logo?: DisplayLogo;
};

export type IssuanceConfig = {
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  /**
   * Authentication server URL for the issuance process.
   */
  authServers?: Array<string>;
  /**
   * Webhook to send the result of the notification response
   */
  notifyWebhook?: WebhookConfig;
  /**
   * Value to determine the amount of credentials that are issued in a batch.
   * Default is 1.
   */
  batchSize?: number;
  /**
   * Indicates whether DPoP is required for the issuance process. Default value is true.
   */
  dPopRequired?: boolean;
  display: Array<DisplayInfo>;
  /**
   * The timestamp when the VP request was created.
   */
  createdAt: string;
  /**
   * The timestamp when the VP request was last updated.
   */
  updatedAt: string;
};

export type IssuanceDto = {
  /**
   * Authentication server URL for the issuance process.
   */
  authServers?: Array<string>;
  /**
   * Webhook to send the result of the notification response
   */
  notifyWebhook?: WebhookConfig;
  /**
   * Value to determine the amount of credentials that are issued in a batch.
   * Default is 1.
   */
  batchSize?: number;
  /**
   * Indicates whether DPoP is required for the issuance process. Default value is true.
   */
  dPopRequired?: boolean;
  display: Array<DisplayInfo>;
};

export type FileUploadDto = {
  file: Blob | File;
};

export type WellKnownControllerIssuerMetadata0Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/.well-known/openid-credential-issuer/{tenantId}";
};

export type WellKnownControllerIssuerMetadata0Responses = {
  200: {
    [key: string]: unknown;
  };
};

export type WellKnownControllerIssuerMetadata0Response =
  WellKnownControllerIssuerMetadata0Responses[keyof WellKnownControllerIssuerMetadata0Responses];

export type WellKnownControllerIssuerMetadata1Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/.well-known/openid-credential-issuer";
};

export type WellKnownControllerIssuerMetadata1Responses = {
  200: {
    [key: string]: unknown;
  };
};

export type WellKnownControllerIssuerMetadata1Response =
  WellKnownControllerIssuerMetadata1Responses[keyof WellKnownControllerIssuerMetadata1Responses];

export type WellKnownControllerAuthzMetadata0Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/.well-known/oauth-authorization-server/{tenantId}";
};

export type WellKnownControllerAuthzMetadata0Responses = {
  200: unknown;
};

export type WellKnownControllerAuthzMetadata1Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/.well-known/oauth-authorization-server";
};

export type WellKnownControllerAuthzMetadata1Responses = {
  200: unknown;
};

export type WellKnownControllerGetJwks0Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/.well-known/jwks.json/{tenantId}";
};

export type WellKnownControllerGetJwks0Responses = {
  200: JwksResponseDto;
};

export type WellKnownControllerGetJwks0Response =
  WellKnownControllerGetJwks0Responses[keyof WellKnownControllerGetJwks0Responses];

export type WellKnownControllerGetJwks1Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/.well-known/jwks.json";
};

export type WellKnownControllerGetJwks1Responses = {
  200: JwksResponseDto;
};

export type WellKnownControllerGetJwks1Response =
  WellKnownControllerGetJwks1Responses[keyof WellKnownControllerGetJwks1Responses];

export type AuthControllerGetOAuth2TokenData = {
  body: ClientCredentialsDto;
  path?: never;
  query?: never;
  url: "/oauth2/token";
};

export type AuthControllerGetOAuth2TokenErrors = {
  /**
   * Invalid client credentials
   */
  401: unknown;
};

export type AuthControllerGetOAuth2TokenResponses = {
  /**
   * OAuth2 token response
   */
  200: TokenResponse;
  201: TokenResponse;
};

export type AuthControllerGetOAuth2TokenResponse =
  AuthControllerGetOAuth2TokenResponses[keyof AuthControllerGetOAuth2TokenResponses];

export type AuthControllerGetOidcDiscoveryData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/.well-known/oauth-authorization-server";
};

export type AuthControllerGetOidcDiscoveryResponses = {
  /**
   * OIDC Discovery Configuration
   */
  200: unknown;
};

export type AuthControllerGetGlobalJwksData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/.well-known/jwks.json";
};

export type AuthControllerGetGlobalJwksResponses = {
  /**
   * JSON Web Key Set
   */
  200: unknown;
};

export type TenantControllerGetTenantsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/tenant";
};

export type TenantControllerGetTenantsResponses = {
  200: Array<TenantEntity>;
};

export type TenantControllerGetTenantsResponse =
  TenantControllerGetTenantsResponses[keyof TenantControllerGetTenantsResponses];

export type TenantControllerInitTenantData = {
  body: CreateTenantDto;
  path?: never;
  query?: never;
  url: "/tenant";
};

export type TenantControllerInitTenantResponses = {
  201: unknown;
};

export type TenantControllerDeleteTenantData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/tenant/{id}";
};

export type TenantControllerDeleteTenantResponses = {
  200: unknown;
};

export type TenantControllerGetTenantData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/tenant/{id}";
};

export type TenantControllerGetTenantResponses = {
  200: TenantEntity;
};

export type TenantControllerGetTenantResponse =
  TenantControllerGetTenantResponses[keyof TenantControllerGetTenantResponses];

export type ClientControllerGetClientsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/client";
};

export type ClientControllerGetClientsResponses = {
  200: Array<ClientEntity>;
};

export type ClientControllerGetClientsResponse =
  ClientControllerGetClientsResponses[keyof ClientControllerGetClientsResponses];

export type ClientControllerCreateClientData = {
  body: CreateClientDto;
  path?: never;
  query?: never;
  url: "/client";
};

export type ClientControllerCreateClientResponses = {
  201: ClientEntity;
};

export type ClientControllerCreateClientResponse =
  ClientControllerCreateClientResponses[keyof ClientControllerCreateClientResponses];

export type ClientControllerDeleteClientData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/client/{id}";
};

export type ClientControllerDeleteClientResponses = {
  200: unknown;
};

export type ClientControllerGetClientData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/client/{id}";
};

export type ClientControllerGetClientResponses = {
  200: ClientEntity;
};

export type ClientControllerGetClientResponse =
  ClientControllerGetClientResponses[keyof ClientControllerGetClientResponses];

export type ClientControllerUpdateClientData = {
  body: UpdateClientDto;
  path: {
    id: string;
  };
  query?: never;
  url: "/client/{id}";
};

export type ClientControllerUpdateClientResponses = {
  200: {
    [key: string]: unknown;
  };
};

export type ClientControllerUpdateClientResponse =
  ClientControllerUpdateClientResponses[keyof ClientControllerUpdateClientResponses];

export type ClientControllerGetClientSecretData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/client/{id}/secret";
};

export type ClientControllerGetClientSecretResponses = {
  200: ClientSecretResponseDto;
};

export type ClientControllerGetClientSecretResponse =
  ClientControllerGetClientSecretResponses[keyof ClientControllerGetClientSecretResponses];

export type KeyControllerGetKeysData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/key";
};

export type KeyControllerGetKeysResponses = {
  200: Array<KeyEntity>;
};

export type KeyControllerGetKeysResponse =
  KeyControllerGetKeysResponses[keyof KeyControllerGetKeysResponses];

export type KeyControllerAddKeyData = {
  body: KeyImportDto;
  path?: never;
  query?: never;
  url: "/key";
};

export type KeyControllerAddKeyResponses = {
  201: unknown;
};

export type KeyControllerDeleteKeyData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/key/{id}";
};

export type KeyControllerDeleteKeyResponses = {
  200: unknown;
};

export type KeyControllerGetKeyData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/key/{id}";
};

export type KeyControllerGetKeyResponses = {
  200: KeyEntity;
};

export type KeyControllerGetKeyResponse =
  KeyControllerGetKeyResponses[keyof KeyControllerGetKeyResponses];

export type KeyControllerUpdateKeyData = {
  body: UpdateKeyDto;
  path: {
    id: string;
  };
  query?: never;
  url: "/key/{id}";
};

export type KeyControllerUpdateKeyResponses = {
  200: unknown;
};

export type CertControllerGetCertificatesData = {
  body?: never;
  path?: never;
  query?: {
    keyId?: string;
  };
  url: "/certs";
};

export type CertControllerGetCertificatesResponses = {
  200: Array<CertEntity>;
};

export type CertControllerGetCertificatesResponse =
  CertControllerGetCertificatesResponses[keyof CertControllerGetCertificatesResponses];

export type CertControllerAddCertificateData = {
  body: CertImportDto;
  path?: never;
  query?: never;
  url: "/certs";
};

export type CertControllerAddCertificateResponses = {
  201: CertResponseDto;
};

export type CertControllerAddCertificateResponse =
  CertControllerAddCertificateResponses[keyof CertControllerAddCertificateResponses];

export type CertControllerDeleteCertificateData = {
  body?: never;
  path: {
    certId: string;
  };
  query?: never;
  url: "/certs/{certId}";
};

export type CertControllerDeleteCertificateResponses = {
  200: unknown;
};

export type CertControllerGetCertificateData = {
  body?: never;
  path: {
    certId: string;
  };
  query?: never;
  url: "/certs/{certId}";
};

export type CertControllerGetCertificateResponses = {
  200: CertEntity;
};

export type CertControllerGetCertificateResponse =
  CertControllerGetCertificateResponses[keyof CertControllerGetCertificateResponses];

export type CertControllerUpdateCertificateData = {
  body: CertUpdateDto;
  path: {
    certId: string;
  };
  query?: never;
  url: "/certs/{certId}";
};

export type CertControllerUpdateCertificateResponses = {
  200: unknown;
};

export type CertControllerAddSelfSignedCertData = {
  body: CertSelfSignedDto;
  path?: never;
  query?: never;
  url: "/certs/self-signed";
};

export type CertControllerAddSelfSignedCertResponses = {
  201: CertResponseDto;
};

export type CertControllerAddSelfSignedCertResponse =
  CertControllerAddSelfSignedCertResponses[keyof CertControllerAddSelfSignedCertResponses];

export type StatusListControllerGetListData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/status-management/status-list";
};

export type StatusListControllerGetListResponses = {
  200: string;
};

export type StatusListControllerGetListResponse =
  StatusListControllerGetListResponses[keyof StatusListControllerGetListResponses];

export type PresentationManagementControllerGetOfferData = {
  body: PresentationRequest;
  path?: never;
  query?: never;
  url: "/presentation-management/request";
};

export type PresentationManagementControllerGetOfferResponses = {
  /**
   * JSON response
   */
  201: OfferResponse;
};

export type PresentationManagementControllerGetOfferResponse =
  PresentationManagementControllerGetOfferResponses[keyof PresentationManagementControllerGetOfferResponses];

export type PresentationManagementControllerConfigurationData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/presentation-management";
};

export type PresentationManagementControllerConfigurationResponses = {
  200: Array<PresentationConfig>;
};

export type PresentationManagementControllerConfigurationResponse =
  PresentationManagementControllerConfigurationResponses[keyof PresentationManagementControllerConfigurationResponses];

export type PresentationManagementControllerStorePresentationConfigData = {
  body: PresentationConfigCreateDto;
  path?: never;
  query?: never;
  url: "/presentation-management";
};

export type PresentationManagementControllerStorePresentationConfigResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type PresentationManagementControllerStorePresentationConfigResponse =
  PresentationManagementControllerStorePresentationConfigResponses[keyof PresentationManagementControllerStorePresentationConfigResponses];

export type PresentationManagementControllerDeleteConfigurationData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/presentation-management/{id}";
};

export type PresentationManagementControllerDeleteConfigurationResponses = {
  200: unknown;
};

export type Oid4VpControllerGetRequestWithSessionData = {
  body?: never;
  path: {
    session: Session;
  };
  query?: never;
  url: "/{session}/oid4vp/request";
};

export type Oid4VpControllerGetRequestWithSessionResponses = {
  200: string;
};

export type Oid4VpControllerGetRequestWithSessionResponse =
  Oid4VpControllerGetRequestWithSessionResponses[keyof Oid4VpControllerGetRequestWithSessionResponses];

export type Oid4VpControllerGetPostRequestWithSessionData = {
  body: AuthorizationResponse;
  path: {
    session: Session;
  };
  query?: never;
  url: "/{session}/oid4vp/request";
};

export type Oid4VpControllerGetPostRequestWithSessionResponses = {
  201: string;
};

export type Oid4VpControllerGetPostRequestWithSessionResponse =
  Oid4VpControllerGetPostRequestWithSessionResponses[keyof Oid4VpControllerGetPostRequestWithSessionResponses];

export type Oid4VpControllerGetResponseData = {
  body: AuthorizationResponse;
  path: {
    session: Session;
  };
  query?: never;
  url: "/{session}/oid4vp";
};

export type Oid4VpControllerGetResponseResponses = {
  200: {
    [key: string]: unknown;
  };
};

export type Oid4VpControllerGetResponseResponse =
  Oid4VpControllerGetResponseResponses[keyof Oid4VpControllerGetResponseResponses];

export type SessionControllerGetAllSessionsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/session";
};

export type SessionControllerGetAllSessionsResponses = {
  200: Array<Session>;
};

export type SessionControllerGetAllSessionsResponse =
  SessionControllerGetAllSessionsResponses[keyof SessionControllerGetAllSessionsResponses];

export type SessionControllerDeleteSessionData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/session/{id}";
};

export type SessionControllerDeleteSessionResponses = {
  200: unknown;
};

export type SessionControllerGetSessionData = {
  body?: never;
  path: {
    /**
     * The session ID
     */
    id: string;
  };
  query?: never;
  url: "/session/{id}";
};

export type SessionControllerGetSessionResponses = {
  200: Session;
};

export type SessionControllerGetSessionResponse =
  SessionControllerGetSessionResponses[keyof SessionControllerGetSessionResponses];

export type SessionControllerRevokeAllData = {
  body: StatusUpdateDto;
  path?: never;
  query?: never;
  url: "/session/revoke";
};

export type SessionControllerRevokeAllResponses = {
  201: unknown;
};

export type Oid4VciControllerCredentialData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/vci/credential";
};

export type Oid4VciControllerCredentialResponses = {
  200: unknown;
};

export type Oid4VciControllerNotificationsData = {
  body: NotificationRequestDto;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/vci/notification";
};

export type Oid4VciControllerNotificationsResponses = {
  201: unknown;
};

export type Oid4VciControllerNonceData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/vci/nonce";
};

export type Oid4VciControllerNonceResponses = {
  200: unknown;
};

export type AuthorizeControllerAuthorizeData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: {
    issuer_state?: string;
    response_type?: string;
    client_id?: string;
    redirect_uri?: string;
    resource?: string;
    scope?: string;
    code_challenge?: string;
    code_challenge_method?: string;
    dpop_jkt?: string;
    request_uri?: string;
    auth_session?: string;
    state?: string;
  };
  url: "/{tenantId}/authorize";
};

export type AuthorizeControllerAuthorizeResponses = {
  200: unknown;
};

export type AuthorizeControllerParData = {
  /**
   * Pushed Authorization Request
   */
  body: AuthorizeQueries;
  path?: never;
  query?: never;
  url: "/{tenantId}/authorize/par";
};

export type AuthorizeControllerParResponses = {
  201: ParResponseDto;
};

export type AuthorizeControllerParResponse =
  AuthorizeControllerParResponses[keyof AuthorizeControllerParResponses];

export type AuthorizeControllerTokenData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/authorize/token";
};

export type AuthorizeControllerTokenResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type AuthorizeControllerTokenResponse =
  AuthorizeControllerTokenResponses[keyof AuthorizeControllerTokenResponses];

export type AuthorizeControllerAuthorizationChallengeEndpointData = {
  body: AuthorizeQueries;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/authorize/challenge";
};

export type AuthorizeControllerAuthorizationChallengeEndpointResponses = {
  201: unknown;
};

export type CredentialsControllerGetConfigsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/issuer-management/credentials";
};

export type CredentialsControllerGetConfigsResponses = {
  200: Array<CredentialConfig>;
};

export type CredentialsControllerGetConfigsResponse =
  CredentialsControllerGetConfigsResponses[keyof CredentialsControllerGetConfigsResponses];

export type CredentialsControllerStoreCredentialConfigurationData = {
  body: CredentialConfigCreate;
  path?: never;
  query?: never;
  url: "/issuer-management/credentials";
};

export type CredentialsControllerStoreCredentialConfigurationResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type CredentialsControllerStoreCredentialConfigurationResponse =
  CredentialsControllerStoreCredentialConfigurationResponses[keyof CredentialsControllerStoreCredentialConfigurationResponses];

export type CredentialsControllerDeleteIssuanceConfigurationData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/issuer-management/credentials/{id}";
};

export type CredentialsControllerDeleteIssuanceConfigurationResponses = {
  200: unknown;
};

export type CredentialsControllerGetConfigByIdData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/issuer-management/credentials/{id}";
};

export type CredentialsControllerGetConfigByIdResponses = {
  200: CredentialConfig;
};

export type CredentialsControllerGetConfigByIdResponse =
  CredentialsControllerGetConfigByIdResponses[keyof CredentialsControllerGetConfigByIdResponses];

export type IssuerManagementControllerGetOfferData = {
  body: OfferRequestDto;
  path?: never;
  query?: never;
  url: "/issuer-management/offer";
};

export type IssuerManagementControllerGetOfferResponses = {
  /**
   * JSON response
   */
  201: OfferResponse;
};

export type IssuerManagementControllerGetOfferResponse =
  IssuerManagementControllerGetOfferResponses[keyof IssuerManagementControllerGetOfferResponses];

export type IssuanceControllerGetIssuanceConfigurationsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/issuer-management/issuance";
};

export type IssuanceControllerGetIssuanceConfigurationsResponses = {
  200: IssuanceConfig;
};

export type IssuanceControllerGetIssuanceConfigurationsResponse =
  IssuanceControllerGetIssuanceConfigurationsResponses[keyof IssuanceControllerGetIssuanceConfigurationsResponses];

export type IssuanceControllerStoreIssuanceConfigurationData = {
  body: IssuanceDto;
  path?: never;
  query?: never;
  url: "/issuer-management/issuance";
};

export type IssuanceControllerStoreIssuanceConfigurationResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type IssuanceControllerStoreIssuanceConfigurationResponse =
  IssuanceControllerStoreIssuanceConfigurationResponses[keyof IssuanceControllerStoreIssuanceConfigurationResponses];

export type CredentialsMetadataControllerVctData = {
  body?: never;
  path: {
    id: string;
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/credentials-metadata/vct/{id}";
};

export type CredentialsMetadataControllerVctResponses = {
  200: Vct;
};

export type CredentialsMetadataControllerVctResponse =
  CredentialsMetadataControllerVctResponses[keyof CredentialsMetadataControllerVctResponses];

export type HealthControllerCheckData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/health";
};

export type HealthControllerCheckErrors = {
  /**
   * The Health Check is not successful
   */
  503: {
    status?: string;
    info?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
    error?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
    details?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
  };
};

export type HealthControllerCheckError =
  HealthControllerCheckErrors[keyof HealthControllerCheckErrors];

export type HealthControllerCheckResponses = {
  /**
   * The Health Check is successful
   */
  200: {
    status?: string;
    info?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
    error?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
    details?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
  };
};

export type HealthControllerCheckResponse =
  HealthControllerCheckResponses[keyof HealthControllerCheckResponses];

export type PrometheusControllerIndexData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/metrics";
};

export type PrometheusControllerIndexResponses = {
  200: unknown;
};

export type StorageControllerUploadData = {
  /**
   * List of cats
   */
  body: FileUploadDto;
  path?: never;
  query?: never;
  url: "/storage";
};

export type StorageControllerUploadResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type StorageControllerUploadResponse =
  StorageControllerUploadResponses[keyof StorageControllerUploadResponses];

export type StorageControllerDownloadData = {
  body?: never;
  path: {
    key: string;
  };
  query?: never;
  url: "/storage/{key}";
};

export type StorageControllerDownloadResponses = {
  200: unknown;
};
