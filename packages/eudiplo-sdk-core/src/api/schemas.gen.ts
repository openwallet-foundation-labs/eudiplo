// This file is auto-generated by @hey-api/openapi-ts

export const RoleDtoSchema = {
  type: "object",
  properties: {
    role: {
      enum: [
        "presentation:manage",
        "presentation:offer",
        "issuance:manage",
        "issuance:offer",
        "clients:manage",
        "tenants:manage",
        "registrar:manage",
      ],
      type: "string",
      description: "OAuth2 roles",
      example: "issuance:manage",
    },
  },
  required: ["role"],
} as const;

export const ClientCredentialsDtoSchema = {
  type: "object",
  properties: {
    grant_type: {
      type: "string",
      default: "client_credentials",
    },
    client_id: {
      type: "string",
    },
    client_secret: {
      type: "string",
    },
  },
  required: ["client_id", "client_secret"],
} as const;

export const TokenResponseSchema = {
  type: "object",
  properties: {
    access_token: {
      type: "string",
    },
    refresh_token: {
      type: "string",
    },
    token_type: {
      type: "string",
    },
    expires_in: {
      type: "number",
    },
  },
  required: ["access_token", "token_type", "expires_in"],
} as const;

export const ImportTenantDtoSchema = {
  type: "object",
  properties: {
    name: {
      type: "string",
      description: "The name of the tenant.",
    },
    description: {
      type: "string",
      description: "The description of the tenant.",
    },
  },
  required: ["name"],
} as const;

export const SessionStorageConfigSchema = {
  type: "object",
  properties: {
    ttlSeconds: {
      type: "number",
      description:
        "Time-to-live for sessions in seconds. If not set, uses global SESSION_TTL.",
      example: 86400,
      minimum: 60,
    },
    cleanupMode: {
      type: "string",
      description:
        "Cleanup mode: 'full' deletes everything, 'anonymize' keeps metadata but removes PII.",
      enum: ["full", "anonymize"],
      default: "full",
    },
  },
} as const;

export const StatusListConfigSchema = {
  type: "object",
  properties: {
    capacity: {
      type: "number",
      description:
        "The capacity of the status list. If not set, uses global STATUS_CAPACITY.",
      example: 10000,
      minimum: 100,
    },
    bits: {
      type: "number",
      description:
        "Bits per status entry: 1 (valid/revoked), 2 (with suspended), 4/8 (extended). If not set, uses global STATUS_BITS.",
      enum: [1, 2, 4, 8],
      default: 1,
    },
    ttl: {
      type: "number",
      description:
        "TTL in seconds for the status list JWT. If not set, uses global STATUS_TTL.",
      example: 3600,
      minimum: 60,
    },
    immediateUpdate: {
      type: "boolean",
      description:
        "If true, regenerate JWT immediately on status changes. If false (default), use lazy regeneration on TTL expiry.",
      default: false,
    },
    enableAggregation: {
      type: "boolean",
      description:
        "If true, include aggregation_uri in status list JWTs for pre-fetching support (default: true).",
      default: true,
    },
  },
} as const;

export const TenantEntitySchema = {
  type: "object",
  properties: {
    sessionConfig: {
      nullable: true,
      description:
        "Session storage configuration for this tenant. Controls TTL and cleanup behavior.",
      allOf: [
        {
          $ref: "#/components/schemas/SessionStorageConfig",
        },
      ],
    },
    statusListConfig: {
      nullable: true,
      description:
        "Status list configuration for this tenant. Only affects newly created status lists.",
      allOf: [
        {
          $ref: "#/components/schemas/StatusListConfig",
        },
      ],
    },
    id: {
      type: "string",
      description: "The unique identifier for the tenant.",
    },
    name: {
      type: "string",
      description: "The name of the tenant.",
    },
    description: {
      type: "string",
      description: "The description of the tenant.",
    },
    status: {
      type: "string",
      description: "The current status of the tenant.",
    },
    clients: {
      description: "The clients associated with the tenant.",
      type: "array",
      items: {
        $ref: "#/components/schemas/ClientEntity",
      },
    },
  },
  required: ["id", "name", "status", "clients"],
} as const;

export const ClientEntitySchema = {
  type: "object",
  properties: {
    allowedPresentationConfigs: {
      nullable: true,
      description:
        "List of presentation config IDs this client can use. If empty/null, all configs are allowed.",
      example: ["age-verification", "kyc-basic"],
      type: "array",
      items: {
        type: "string",
      },
    },
    allowedIssuanceConfigs: {
      nullable: true,
      description:
        "List of issuance config IDs this client can use. If empty/null, all configs are allowed.",
      example: ["pid", "mdl"],
      type: "array",
      items: {
        type: "string",
      },
    },
    clientId: {
      type: "string",
      description: "The unique identifier for the client.",
    },
    secret: {
      type: "string",
      description: "The secret key for the client.",
    },
    tenantId: {
      type: "string",
      description:
        "The unique identifier for the tenant that the client belongs to. Only null for accounts that manage tenants, that do not belong to a client",
    },
    description: {
      type: "string",
      description: "The description of the client.",
    },
    roles: {
      description: "The roles assigned to the client.",
      type: "array",
      items: {
        type: "string",
        enum: [
          "presentation:manage",
          "presentation:offer",
          "issuance:manage",
          "issuance:offer",
          "clients:manage",
          "tenants:manage",
          "registrar:manage",
        ],
      },
    },
    tenant: {
      description: "The tenant that the client belongs to.",
      allOf: [
        {
          $ref: "#/components/schemas/TenantEntity",
        },
      ],
    },
  },
  required: ["clientId", "roles"],
} as const;

export const CreateTenantDtoSchema = {
  type: "object",
  properties: {
    statusListConfig: {
      nullable: true,
      description:
        "Status list configuration for this tenant. Only affects newly created status lists.",
      allOf: [
        {
          $ref: "#/components/schemas/StatusListConfig",
        },
      ],
    },
    sessionConfig: {
      description:
        "Session storage configuration. Controls TTL and cleanup behavior.",
      allOf: [
        {
          $ref: "#/components/schemas/SessionStorageConfig",
        },
      ],
    },
    roles: {
      type: "array",
      items: {
        type: "string",
        enum: [
          "presentation:manage",
          "presentation:offer",
          "issuance:manage",
          "issuance:offer",
          "clients:manage",
          "tenants:manage",
          "registrar:manage",
        ],
      },
    },
    id: {
      type: "string",
      description: "The unique identifier for the tenant.",
    },
    name: {
      type: "string",
      description: "The name of the tenant.",
    },
    description: {
      type: "string",
      description: "The description of the tenant.",
    },
  },
  required: ["id", "name"],
} as const;

export const UpdateTenantDtoSchema = {
  type: "object",
  properties: {
    statusListConfig: {
      nullable: true,
      description:
        "Status list configuration for this tenant. Only affects newly created status lists.",
      allOf: [
        {
          $ref: "#/components/schemas/StatusListConfig",
        },
      ],
    },
    sessionConfig: {
      description:
        "Session storage configuration. Controls TTL and cleanup behavior.",
      allOf: [
        {
          $ref: "#/components/schemas/SessionStorageConfig",
        },
      ],
    },
    name: {
      type: "string",
      description: "The name of the tenant.",
    },
    description: {
      type: "string",
      description: "The description of the tenant.",
    },
    roles: {
      type: "array",
      items: {
        type: "string",
        enum: [
          "presentation:manage",
          "presentation:offer",
          "issuance:manage",
          "issuance:offer",
          "clients:manage",
          "tenants:manage",
          "registrar:manage",
        ],
      },
    },
  },
} as const;

export const ClientSecretResponseDtoSchema = {
  type: "object",
  properties: {
    secret: {
      type: "string",
    },
  },
  required: ["secret"],
} as const;

export const UpdateClientDtoSchema = {
  type: "object",
  properties: {
    allowedPresentationConfigs: {
      nullable: true,
      description:
        "List of presentation config IDs this client can use. If empty/null, all configs are allowed.",
      example: ["age-verification", "kyc-basic"],
      type: "array",
      items: {
        type: "string",
      },
    },
    allowedIssuanceConfigs: {
      nullable: true,
      description:
        "List of issuance config IDs this client can use. If empty/null, all configs are allowed.",
      example: ["pid", "mdl"],
      type: "array",
      items: {
        type: "string",
      },
    },
    description: {
      type: "string",
      description: "The description of the client.",
    },
    roles: {
      type: "array",
      description: "The roles assigned to the client.",
      items: {
        type: "string",
        enum: [
          "presentation:manage",
          "presentation:offer",
          "issuance:manage",
          "issuance:offer",
          "clients:manage",
          "tenants:manage",
          "registrar:manage",
        ],
      },
    },
  },
  required: ["roles"],
} as const;

export const CreateClientDtoSchema = {
  type: "object",
  properties: {
    allowedPresentationConfigs: {
      nullable: true,
      description:
        "List of presentation config IDs this client can use. If empty/null, all configs are allowed.",
      example: ["age-verification", "kyc-basic"],
      type: "array",
      items: {
        type: "string",
      },
    },
    allowedIssuanceConfigs: {
      nullable: true,
      description:
        "List of issuance config IDs this client can use. If empty/null, all configs are allowed.",
      example: ["pid", "mdl"],
      type: "array",
      items: {
        type: "string",
      },
    },
    clientId: {
      type: "string",
      description: "The unique identifier for the client.",
    },
    secret: {
      type: "string",
      description: "The secret key for the client.",
    },
    description: {
      type: "string",
      description: "The description of the client.",
    },
    roles: {
      type: "array",
      description: "The roles assigned to the client.",
      items: {
        type: "string",
        enum: [
          "presentation:manage",
          "presentation:offer",
          "issuance:manage",
          "issuance:offer",
          "clients:manage",
          "tenants:manage",
          "registrar:manage",
        ],
      },
    },
  },
  required: ["clientId", "roles"],
} as const;

export const CertUsageEntitySchema = {
  type: "object",
  properties: {
    tenantId: {
      type: "string",
    },
    certId: {
      type: "string",
    },
    usage: {
      type: "string",
      enum: ["access", "signing", "trustList", "statusList"],
    },
    cert: {
      $ref: "#/components/schemas/CertEntity",
    },
  },
  required: ["tenantId", "certId", "usage", "cert"],
} as const;

export const KeyEntitySchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the key.",
    },
    description: {
      type: "string",
      description: "Description of the key.",
    },
    tenantId: {
      type: "string",
      description: "Tenant ID for the key.",
    },
    tenant: {
      description: "The tenant that owns this object.",
      allOf: [
        {
          $ref: "#/components/schemas/TenantEntity",
        },
      ],
    },
    key: {
      type: "object",
      description: "The key material.",
    },
    usage: {
      type: "object",
      description: "The usage type of the key.",
    },
    certificates: {
      description: "Certificates associated with this key.",
      type: "array",
      items: {
        $ref: "#/components/schemas/CertEntity",
      },
    },
    createdAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the key was created.",
    },
    updatedAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the key was last updated.",
    },
  },
  required: [
    "id",
    "tenantId",
    "tenant",
    "key",
    "usage",
    "certificates",
    "createdAt",
    "updatedAt",
  ],
} as const;

export const CertEntitySchema = {
  type: "object",
  properties: {
    keyId: {
      type: "string",
      description: "The key ID this certificate is associated with",
      example: "039af178-3ca0-48f4-a2e4-7b1209f30376",
    },
    id: {
      type: "string",
      description: "Unique identifier for the key.",
    },
    tenantId: {
      type: "string",
      description: "Tenant ID for the key.",
    },
    tenant: {
      description: "The tenant that owns this object.",
      allOf: [
        {
          $ref: "#/components/schemas/TenantEntity",
        },
      ],
    },
    crt: {
      type: "string",
      description: "Certificate in PEM format.",
    },
    usages: {
      type: "array",
      items: {
        $ref: "#/components/schemas/CertUsageEntity",
      },
    },
    description: {
      type: "string",
      description: "Description of the key.",
    },
    key: {
      $ref: "#/components/schemas/KeyEntity",
    },
    createdAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the certificate was created.",
    },
    updatedAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the certificate was last updated.",
    },
  },
  required: [
    "keyId",
    "id",
    "tenantId",
    "tenant",
    "crt",
    "usages",
    "key",
    "createdAt",
    "updatedAt",
  ],
} as const;

export const KeySchema = {
  type: "object",
  properties: {
    kty: {
      type: "string",
    },
    x: {
      type: "string",
    },
    y: {
      type: "string",
    },
    crv: {
      type: "string",
    },
    d: {
      type: "string",
    },
    alg: {
      type: "string",
    },
  },
  required: ["kty", "x", "y", "crv", "d", "alg"],
} as const;

export const KeyImportDtoSchema = {
  type: "object",
  properties: {
    key: {
      description: "The private key in JWK format.",
      allOf: [
        {
          $ref: "#/components/schemas/Key",
        },
      ],
    },
    id: {
      type: "string",
      description: "Unique identifier for the key.",
    },
    description: {
      type: "string",
      description: "Description of the key.",
    },
  },
  required: ["key", "id"],
} as const;

export const UpdateKeyDtoSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the key.",
    },
    description: {
      type: "string",
      description: "Description of the key.",
    },
  },
  required: ["id"],
} as const;

export const CertImportDtoSchema = {
  type: "object",
  properties: {
    keyId: {
      type: "string",
      description: "The key ID this certificate is associated with",
      example: "039af178-3ca0-48f4-a2e4-7b1209f30376",
    },
    id: {
      type: "string",
    },
    certUsageTypes: {
      description: "Usage types for the certificate.",
      type: "array",
      items: {
        type: "string",
        enum: ["access", "signing", "trustList", "statusList"],
      },
    },
    crt: {
      type: "string",
      description:
        "Certificate in PEM format, if not provided, a self-signed certificate will be generated.",
    },
    subjectName: {
      type: "string",
      description:
        "Subject name (CN) for self-signed certificate generation.\nIf not provided, the tenant name will be used.",
    },
    description: {
      type: "string",
      description: "Description of the key.",
    },
  },
  required: ["keyId", "certUsageTypes"],
} as const;

export const CertResponseDtoSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "The ID of the created self-signed certificate.",
    },
  },
  required: ["id"],
} as const;

export const CertUpdateDtoSchema = {
  type: "object",
  properties: {
    certUsageTypes: {
      type: "array",
      description: "Usage types for the certificate.",
      items: {
        type: "string",
        enum: ["access", "signing", "trustList", "statusList"],
      },
    },
    usages: {
      type: "array",
      items: {
        $ref: "#/components/schemas/CertUsageEntity",
      },
    },
    description: {
      type: "string",
      description: "Description of the key.",
    },
  },
  required: ["certUsageTypes", "usages"],
} as const;

export const StatusListImportDtoSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the status list",
    },
    credentialConfigurationId: {
      type: "string",
      nullable: true,
      description:
        "Credential configuration ID to bind this list exclusively to. Leave empty for a shared list.",
      example: "org.iso.18013.5.1.mDL",
    },
    certId: {
      type: "string",
      description:
        "Certificate ID to use for signing. Leave empty to use the tenant's default StatusList certificate.",
      example: "my-status-list-cert",
    },
    capacity: {
      type: "number",
      description:
        "Capacity of the status list. If not provided, uses tenant or global defaults.",
      minimum: 100,
      example: 10000,
    },
    bits: {
      type: "number",
      description:
        "Bits per status value. If not provided, uses tenant or global defaults.",
      enum: [1, 2, 4, 8],
      example: 1,
    },
  },
  required: ["id"],
} as const;

export const StatusListAggregationDtoSchema = {
  type: "object",
  properties: {
    status_lists: {
      description: "Array of status list token URIs",
      example: [
        "https://example.com/tenant-123/status-management/status-list/list-1",
        "https://example.com/tenant-123/status-management/status-list/list-2",
      ],
      type: "array",
      items: {
        type: "string",
      },
    },
  },
  required: ["status_lists"],
} as const;

export const UpdateStatusListConfigDtoSchema = {
  type: "object",
  properties: {
    capacity: {
      type: "number",
      nullable: true,
      description:
        "The capacity of the status list. Set to null to reset to global default.",
      minimum: 100,
      example: 10000,
    },
    bits: {
      type: "number",
      nullable: true,
      description:
        "Bits per status entry. Set to null to reset to global default.",
      enum: [1, 2, 4, 8],
    },
    ttl: {
      type: "number",
      nullable: true,
      description:
        "TTL in seconds for the status list JWT. Set to null to reset to global default.",
      minimum: 60,
      example: 3600,
    },
    immediateUpdate: {
      type: "boolean",
      nullable: true,
      description:
        "If true, regenerate JWT on every status change. Set to null to reset to default (false).",
    },
    enableAggregation: {
      type: "boolean",
      nullable: true,
      description:
        "If true, include aggregation_uri in status list JWTs for pre-fetching support. Set to null to reset to default (true).",
    },
  },
} as const;

export const StatusListResponseDtoSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the status list",
      example: "550e8400-e29b-41d4-a716-446655440000",
    },
    tenantId: {
      type: "string",
      description: "The tenant ID",
      example: "root",
    },
    credentialConfigurationId: {
      type: "string",
      nullable: true,
      description:
        "Credential configuration ID this list is bound to. Null means shared.",
      example: "org.iso.18013.5.1.mDL",
    },
    certId: {
      type: "string",
      nullable: true,
      description:
        "Certificate ID used for signing. Null means using the tenant's default.",
      example: "my-status-list-cert",
    },
    bits: {
      type: "number",
      description: "Bits per status value",
      enum: [1, 2, 4, 8],
      example: 1,
    },
    capacity: {
      type: "number",
      description: "Total capacity of the status list",
      example: 10000,
    },
    usedEntries: {
      type: "number",
      description: "Number of entries in use",
      example: 150,
    },
    availableEntries: {
      type: "number",
      description: "Number of available entries",
      example: 9850,
    },
    uri: {
      type: "string",
      description: "The public URI for this status list",
      example:
        "https://example.com/root/status-management/status-list/550e8400-e29b-41d4-a716-446655440000",
    },
    createdAt: {
      format: "date-time",
      type: "string",
      description: "Creation timestamp",
      example: "2024-01-15T10:30:00.000Z",
    },
    expiresAt: {
      format: "date-time",
      type: "string",
      nullable: true,
      description:
        "JWT expiration timestamp. Null if JWT has not been generated yet.",
      example: "2024-01-15T11:30:00.000Z",
    },
  },
  required: [
    "id",
    "tenantId",
    "bits",
    "capacity",
    "usedEntries",
    "availableEntries",
    "uri",
    "createdAt",
  ],
} as const;

export const CreateStatusListDtoSchema = {
  type: "object",
  properties: {
    credentialConfigurationId: {
      type: "string",
      description:
        "Credential configuration ID to bind this list exclusively to. Leave empty for a shared list.",
      example: "org.iso.18013.5.1.mDL",
    },
    certId: {
      type: "string",
      description:
        "Certificate ID to use for signing. Leave empty to use the tenant's default StatusList certificate.",
      example: "my-status-list-cert",
    },
    bits: {
      type: "number",
      description:
        "Bits per status value. More bits allow more status states. Defaults to tenant configuration.",
      enum: [1, 2, 4, 8],
      example: 1,
    },
    capacity: {
      type: "number",
      description:
        "Maximum number of credential status entries. Defaults to tenant configuration.",
      minimum: 1000,
      example: 100000,
    },
  },
} as const;

export const UpdateStatusListDtoSchema = {
  type: "object",
  properties: {
    credentialConfigurationId: {
      type: "string",
      nullable: true,
      description:
        "Credential configuration ID to bind this list exclusively to. Set to null to make this a shared list.",
      example: "org.iso.18013.5.1.mDL",
    },
    certId: {
      type: "string",
      nullable: true,
      description:
        "Certificate ID to use for signing. Set to null to use the tenant's default StatusList certificate.",
      example: "my-status-list-cert",
    },
  },
} as const;

export const AuthorizeQueriesSchema = {
  type: "object",
  properties: {
    issuer_state: {
      type: "string",
    },
    response_type: {
      type: "string",
    },
    client_id: {
      type: "string",
    },
    redirect_uri: {
      type: "string",
    },
    resource: {
      type: "string",
    },
    scope: {
      type: "string",
    },
    code_challenge: {
      type: "string",
    },
    code_challenge_method: {
      type: "string",
    },
    dpop_jkt: {
      type: "string",
    },
    request_uri: {
      type: "string",
    },
    auth_session: {
      type: "string",
    },
    state: {
      type: "string",
    },
  },
} as const;

export const WebHookAuthConfigNoneSchema = {
  type: "object",
  properties: {
    type: {
      type: "string",
      description: "The type of authentication used for the webhook.",
      enum: ["none"],
    },
  },
  required: ["type"],
} as const;

export const ApiKeyConfigSchema = {
  type: "object",
  properties: {
    headerName: {
      type: "string",
      description: "The name of the header where the API key will be sent.",
    },
    value: {
      type: "string",
      description: "The value of the API key to be sent in the header.",
    },
  },
  required: ["headerName", "value"],
} as const;

export const WebHookAuthConfigHeaderSchema = {
  type: "object",
  properties: {
    type: {
      type: "string",
      description: "The type of authentication used for the webhook.",
      enum: ["apiKey"],
    },
    config: {
      description:
        "Configuration for API key authentication.\nThis is required if the type is 'apiKey'.",
      allOf: [
        {
          $ref: "#/components/schemas/ApiKeyConfig",
        },
      ],
    },
  },
  required: ["type", "config"],
} as const;

export const WebhookConfigSchema = {
  type: "object",
  properties: {
    auth: {
      description:
        "Optional authentication configuration for the webhook.\nIf not provided, no authentication will be used.",
      oneOf: [
        {
          $ref: "#/components/schemas/WebHookAuthConfigNone",
        },
        {
          $ref: "#/components/schemas/WebHookAuthConfigHeader",
        },
      ],
    },
    url: {
      type: "string",
      description: "The URL to which the webhook will send notifications.",
    },
  },
  required: ["auth", "url"],
} as const;

export const OfferRequestDtoSchema = {
  type: "object",
  properties: {
    response_type: {
      enum: ["qrcode", "uri", "dc-api"],
      type: "string",
      examples: [
        {
          value: "qrcode",
        },
      ],
      description: "The type of response expected for the offer request.",
    },
    credentialClaims: {
      type: "object",
      description:
        "Credential claims configuration per credential. Keys must match credentialConfigurationIds.",
      properties: {
        additionalProperties: {
          oneOf: [
            {
              type: "object",
              properties: {
                type: {
                  type: "string",
                  enum: ["inline"],
                },
                claims: {
                  type: "object",
                  additionalProperties: true,
                },
              },
              required: ["type", "claims"],
            },
            {
              type: "object",
              properties: {
                type: {
                  type: "string",
                  enum: ["webhook"],
                },
                webhook: {
                  type: "object",
                },
              },
              required: ["type", "webhook"],
            },
          ],
        },
      },
      example: {
        citizen: {
          type: "inline",
          claims: {
            given_name: "John",
            family_name: "Doe",
          },
        },
      },
    },
    flow: {
      description: "The flow type for the offer request.",
      enum: ["authorization_code", "pre_authorized_code"],
      type: "string",
    },
    tx_code: {
      type: "string",
      description: "Transaction code for pre-authorized code flow.",
    },
    credentialConfigurationIds: {
      description:
        "List of credential configuration ids to be included in the offer.",
      type: "array",
      items: {
        type: "string",
      },
    },
    authorization_server: {
      type: "string",
      description:
        "Optional authorization server to be used for this issuance flow.",
    },
    notifyWebhook: {
      description:
        "Webhook to notify about the status of the issuance process.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
  },
  required: ["response_type", "flow", "credentialConfigurationIds"],
} as const;

export const TransactionDataSchema = {
  type: "object",
  properties: {
    type: {
      type: "string",
    },
    credential_ids: {
      type: "array",
      items: {
        type: "string",
      },
    },
  },
  required: ["type", "credential_ids"],
} as const;

export const SessionSchema = {
  type: "object",
  properties: {
    status: {
      description: "Status of the session.",
      enum: ["active", "fetched", "completed", "expired", "failed"],
      type: "string",
    },
    id: {
      type: "string",
      description: "Unique identifier for the session.",
    },
    createdAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the request was created.",
    },
    updatedAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the request was last updated.",
    },
    expiresAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the request is set to expire.",
    },
    useDcApi: {
      type: "boolean",
      description:
        "Flag indicating whether to use the DC API for the presentation request.",
    },
    tenantId: {
      type: "string",
      description: "Tenant ID for multi-tenancy support.",
    },
    tenant: {
      description: "The tenant that owns this object.",
      allOf: [
        {
          $ref: "#/components/schemas/TenantEntity",
        },
      ],
    },
    authorization_code: {
      type: "string",
    },
    request_uri: {
      type: "string",
      description: "Request URI from the authorization request.",
    },
    auth_queries: {
      description: "Authorization queries associated with the session.",
      allOf: [
        {
          $ref: "#/components/schemas/AuthorizeQueries",
        },
      ],
    },
    offer: {
      description:
        "Credential offer object containing details about the credential offer or presentation request.",
      type: "object",
    },
    offerUrl: {
      type: "string",
      description: "Offer URL for the credential offer.",
    },
    credentialPayload: {
      description: "Credential payload containing the offer request details.",
      allOf: [
        {
          $ref: "#/components/schemas/OfferRequestDto",
        },
      ],
    },
    notifyWebhook: {
      description:
        "Webhook configuration to send the result of the notification response.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    notifications: {
      description: "Notifications associated with the session.",
      type: "array",
      items: {
        type: "object",
      },
    },
    requestId: {
      type: "string",
    },
    requestUrl: {
      type: "string",
      description: "The URL of the presentation auth request.",
    },
    requestObject: {
      type: "string",
      description: "Signed presentation auth request.",
    },
    credentials: {
      description: "Verified credentials from the presentation process.",
      type: "array",
      items: {
        type: "object",
      },
    },
    vp_nonce: {
      type: "string",
      description: "Noncce from the Verifiable Presentation request.",
    },
    clientId: {
      type: "string",
      description: "Client ID used in the OID4VP authorization request.",
    },
    responseUri: {
      type: "string",
      description: "Response URI used in the OID4VP authorization request.",
    },
    redirectUri: {
      type: "string",
      nullable: true,
      description:
        "Redirect URI to which the user-agent should be redirected after the presentation is completed.",
    },
    parsedWebhook: {
      description: "Where to send the claims webhook response.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    transaction_data: {
      description:
        "Transaction data to include in the OID4VP authorization request.\nCan be overridden per-request from the presentation configuration.",
      type: "array",
      items: {
        $ref: "#/components/schemas/TransactionData",
      },
    },
  },
  required: [
    "status",
    "id",
    "createdAt",
    "updatedAt",
    "useDcApi",
    "tenantId",
    "tenant",
    "notifications",
  ],
} as const;

export const StatusUpdateDtoSchema = {
  type: "object",
  properties: {
    sessionId: {
      type: "string",
      description: "The session ID of the user",
    },
    credentialConfigurationId: {
      type: "string",
      description:
        "The ID of the credential configuration\nThis is optional, if not provided, all credentials will be revoked of the session.",
    },
    status: {
      type: "number",
      description:
        "The status of the credential\n0 = valid, 1 = revoked, 2 = suspended",
    },
  },
  required: ["sessionId", "status"],
} as const;

export const UpdateSessionConfigDtoSchema = {
  type: "object",
  properties: {
    ttlSeconds: {
      type: "number",
      nullable: true,
      description:
        "Time-to-live for sessions in seconds. Set to null to use global default.",
      minimum: 60,
      example: 86400,
    },
    cleanupMode: {
      description:
        "Cleanup mode: 'full' deletes everything, 'anonymize' keeps metadata but removes PII.",
      enum: ["full", "anonymize"],
      type: "string",
      default: "full",
    },
  },
} as const;

export const AuthenticationMethodNoneSchema = {
  type: "object",
  properties: {
    method: {
      type: "string",
      enum: ["none"],
    },
  },
  required: ["method"],
} as const;

export const AuthenticationUrlConfigSchema = {
  type: "object",
  properties: {
    url: {
      type: "string",
      description:
        "The URL used in the OID4VCI authorized code flow.\nThis URL is where users will be redirected for authentication.",
    },
    webhook: {
      description:
        "Optional webhook configuration for authentication callbacks",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
  },
  required: ["url"],
} as const;

export const AuthenticationMethodAuthSchema = {
  type: "object",
  properties: {
    method: {
      type: "string",
      enum: ["auth"],
    },
    config: {
      $ref: "#/components/schemas/AuthenticationUrlConfig",
    },
  },
  required: ["method", "config"],
} as const;

export const PresentationDuringIssuanceConfigSchema = {
  type: "object",
  properties: {
    type: {
      type: "string",
      description:
        "Link to the presentation configuration that is relevant for the issuance process",
    },
  },
  required: ["type"],
} as const;

export const AuthenticationMethodPresentationSchema = {
  type: "object",
  properties: {
    method: {
      type: "string",
      enum: ["presentationDuringIssuance"],
    },
    config: {
      $ref: "#/components/schemas/PresentationDuringIssuanceConfig",
    },
  },
  required: ["method", "config"],
} as const;

export const DisplayLogoSchema = {
  type: "object",
  properties: {
    uri: {
      type: "string",
    },
    alt_text: {
      type: "string",
    },
  },
  required: ["uri"],
} as const;

export const DisplayInfoSchema = {
  type: "object",
  properties: {
    name: {
      type: "string",
    },
    locale: {
      type: "string",
    },
    logo: {
      $ref: "#/components/schemas/DisplayLogo",
    },
  },
} as const;

export const IssuanceConfigSchema = {
  type: "object",
  properties: {
    tenant: {
      description: "The tenant that owns this object.",
      allOf: [
        {
          $ref: "#/components/schemas/TenantEntity",
        },
      ],
    },
    authServers: {
      description: "Authentication server URL for the issuance process.",
      type: "array",
      items: {
        type: "string",
      },
    },
    batchSize: {
      type: "number",
      description:
        "Value to determine the amount of credentials that are issued in a batch.\nDefault is 1.",
    },
    dPopRequired: {
      type: "boolean",
      description:
        "Indicates whether DPoP is required for the issuance process. Default value is true.",
    },
    walletAttestationRequired: {
      type: "boolean",
      description:
        "Indicates whether wallet attestation is required for the token endpoint.\nWhen enabled, wallets must provide OAuth-Client-Attestation headers.\nDefault value is false.",
    },
    walletProviderTrustLists: {
      description:
        "URLs of trust lists containing trusted wallet providers.\nThe wallet attestation's X.509 certificate will be validated against these trust lists.\nIf empty and walletAttestationRequired is true, all wallet providers are rejected.",
      type: "array",
      items: {
        type: "string",
      },
    },
    display: {
      type: "array",
      items: {
        $ref: "#/components/schemas/DisplayInfo",
      },
    },
    createdAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the VP request was created.",
    },
    updatedAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the VP request was last updated.",
    },
  },
  required: ["tenant", "display", "createdAt", "updatedAt"],
} as const;

export const IssuanceDtoSchema = {
  type: "object",
  properties: {
    authServers: {
      description: "Authentication server URL for the issuance process.",
      type: "array",
      items: {
        type: "string",
      },
    },
    batchSize: {
      type: "number",
      description:
        "Value to determine the amount of credentials that are issued in a batch.\nDefault is 1.",
    },
    dPopRequired: {
      type: "boolean",
      description:
        "Indicates whether DPoP is required for the issuance process. Default value is true.",
    },
    walletAttestationRequired: {
      type: "boolean",
      description:
        "Indicates whether wallet attestation is required for the token endpoint.\nWhen enabled, wallets must provide OAuth-Client-Attestation headers.\nDefault value is false.",
    },
    walletProviderTrustLists: {
      description:
        "URLs of trust lists containing trusted wallet providers.\nThe wallet attestation's X.509 certificate will be validated against these trust lists.\nIf empty and walletAttestationRequired is true, all wallet providers are rejected.",
      type: "array",
      items: {
        type: "string",
      },
    },
    display: {
      type: "array",
      items: {
        $ref: "#/components/schemas/DisplayInfo",
      },
    },
  },
  required: ["display"],
} as const;

export const ClaimsQuerySchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
    },
    path: {
      type: "array",
      items: {
        type: "string",
      },
    },
    values: {
      type: "array",
      items: {
        type: "object",
      },
    },
  },
  required: ["id", "path"],
} as const;

export const ClaimSchema = {
  type: "object",
  properties: {
    path: {
      type: "array",
      items: {
        type: "string",
      },
    },
  },
  required: ["path"],
} as const;

export const TrustedAuthorityQuerySchema = {
  type: "object",
  properties: {
    type: {
      type: "string",
      enum: ["aki", "etsi_tl"],
    },
    values: {
      type: "array",
      items: {
        type: "string",
      },
    },
  },
  required: ["type", "values"],
} as const;

export const CredentialQuerySchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
    },
    format: {
      type: "string",
    },
    multiple: {
      type: "boolean",
    },
    claims: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Claim",
      },
    },
    meta: {
      type: "object",
    },
    trusted_authorities: {
      type: "array",
      items: {
        $ref: "#/components/schemas/TrustedAuthorityQuery",
      },
    },
  },
  required: ["id", "format", "meta"],
} as const;

export const CredentialSetQuerySchema = {
  type: "object",
  properties: {
    options: {
      type: "array",
      items: {
        type: "array",
        items: {
          type: "string",
        },
      },
    },
    required: {
      type: "boolean",
    },
  },
  required: ["options"],
} as const;

export const PolicyCredentialSchema = {
  type: "object",
  properties: {
    claims: {
      type: "array",
      items: {
        $ref: "#/components/schemas/ClaimsQuery",
      },
    },
    credentials: {
      type: "array",
      items: {
        $ref: "#/components/schemas/CredentialQuery",
      },
    },
    credential_sets: {
      type: "array",
      items: {
        $ref: "#/components/schemas/CredentialSetQuery",
      },
    },
  },
  required: ["credentials"],
} as const;

export const AttestationBasedPolicySchema = {
  type: "object",
  properties: {
    policy: {
      type: "string",
      enum: ["attestationBased"],
    },
    values: {
      type: "array",
      items: {
        $ref: "#/components/schemas/PolicyCredential",
      },
    },
  },
  required: ["policy", "values"],
} as const;

export const NoneTrustPolicySchema = {
  type: "object",
  properties: {
    policy: {
      type: "string",
      enum: ["none"],
    },
  },
  required: ["policy"],
} as const;

export const AllowListPolicySchema = {
  type: "object",
  properties: {
    policy: {
      type: "string",
      enum: ["allowList"],
    },
    values: {
      type: "array",
      items: {
        type: "string",
      },
    },
  },
  required: ["policy", "values"],
} as const;

export const RootOfTrustPolicySchema = {
  type: "object",
  properties: {
    policy: {
      type: "string",
      enum: ["rootOfTrust"],
    },
    values: {
      type: "string",
    },
  },
  required: ["policy", "values"],
} as const;

export const VCTSchema = {
  type: "object",
  properties: {
    vct: {
      type: "string",
    },
    name: {
      type: "string",
    },
    description: {
      type: "string",
    },
    extends: {
      type: "string",
    },
    "extends#integrity": {
      type: "string",
    },
    schema_uri: {
      type: "string",
    },
    "schema_uri#integrity": {
      type: "string",
    },
  },
} as const;

export const EmbeddedDisclosurePolicySchema = {
  type: "object",
  properties: {
    policy: {
      type: "string",
    },
  },
  required: ["policy"],
} as const;

export const DisplayImageSchema = {
  type: "object",
  properties: {
    uri: {
      type: "string",
    },
  },
  required: ["uri"],
} as const;

export const DisplaySchema = {
  type: "object",
  properties: {
    name: {
      type: "string",
    },
    description: {
      type: "string",
    },
    locale: {
      type: "string",
    },
    background_color: {
      type: "string",
    },
    text_color: {
      type: "string",
    },
    background_image: {
      $ref: "#/components/schemas/DisplayImage",
    },
    logo: {
      $ref: "#/components/schemas/DisplayImage",
    },
  },
  required: ["name", "description", "locale"],
} as const;

export const IssuerMetadataCredentialConfigSchema = {
  type: "object",
  properties: {
    format: {
      type: "string",
    },
    display: {
      type: "array",
      items: {
        $ref: "#/components/schemas/Display",
      },
    },
    scope: {
      type: "string",
    },
    docType: {
      type: "string",
      description:
        'Document type for mDOC credentials (e.g., "org.iso.18013.5.1.mDL").\nOnly applicable when format is "mso_mdoc".',
    },
    namespace: {
      type: "string",
      description:
        'Namespace for mDOC credentials (e.g., "org.iso.18013.5.1").\nOnly applicable when format is "mso_mdoc".\nUsed when claims are provided as a flat object.',
    },
    claimsByNamespace: {
      type: "object",
      description:
        'Claims organized by namespace for mDOC credentials.\nAllows specifying claims across multiple namespaces.\nOnly applicable when format is "mso_mdoc".\nExample:\n{\n  "org.iso.18013.5.1": { "given_name": "John", "family_name": "Doe" },\n  "org.iso.18013.5.1.aamva": { "DHS_compliance": "F" }\n}',
    },
  },
  required: ["format", "display"],
} as const;

export const SchemaResponseSchema = {
  type: "object",
  properties: {
    $schema: {
      type: "string",
    },
    type: {
      type: "string",
    },
    properties: {
      type: "object",
    },
    required: {
      type: "array",
      items: {
        type: "string",
      },
    },
    title: {
      type: "string",
    },
    description: {
      type: "string",
    },
  },
  required: ["$schema", "type", "properties"],
} as const;

export const CredentialConfigSchema = {
  type: "object",
  properties: {
    vct: {
      description:
        "VCT as a URI string (e.g., urn:eudi:pid:de:1) or as an object for EUDIPLO-hosted VCT",
      nullable: true,
      oneOf: [
        {
          type: "string",
          description: "VCT URI string",
        },
        {
          $ref: "#/components/schemas/VCT",
        },
      ],
    },
    embeddedDisclosurePolicy: {
      nullable: true,
      description:
        "Embedded disclosure policy (discriminated union by `policy`).\nThe discriminator makes class-transformer instantiate the right subclass,\nand then class-validator runs that subclass’s rules.",
      oneOf: [
        {
          $ref: "#/components/schemas/AttestationBasedPolicy",
        },
        {
          $ref: "#/components/schemas/NoneTrustPolicy",
        },
        {
          $ref: "#/components/schemas/AllowListPolicy",
        },
        {
          $ref: "#/components/schemas/RootOfTrustPolicy",
        },
      ],
      allOf: [
        {
          $ref: "#/components/schemas/EmbeddedDisclosurePolicy",
        },
      ],
    },
    id: {
      type: "string",
    },
    description: {
      type: "string",
      nullable: true,
    },
    tenant: {
      description: "The tenant that owns this object.",
      allOf: [
        {
          $ref: "#/components/schemas/TenantEntity",
        },
      ],
    },
    config: {
      $ref: "#/components/schemas/IssuerMetadataCredentialConfig",
    },
    claims: {
      type: "object",
      nullable: true,
    },
    claimsWebhook: {
      nullable: true,
      description: "Webhook to receive claims for the issuance process.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    notificationWebhook: {
      nullable: true,
      description: "Webhook to receive claims for the issuance process.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    disclosureFrame: {
      type: "object",
      nullable: true,
    },
    keyBinding: {
      type: "boolean",
    },
    certId: {
      type: "string",
      description:
        "Reference to the certificate used for signing.\nNote: No DB-level FK constraint because CertEntity has a composite PK\n(id + tenantId) and SET NULL behavior cannot work when tenantId is\npart of this entity's own PK.",
    },
    cert: {
      $ref: "#/components/schemas/CertEntity",
    },
    statusManagement: {
      type: "boolean",
    },
    lifeTime: {
      type: "number",
    },
    schema: {
      nullable: true,
      allOf: [
        {
          $ref: "#/components/schemas/SchemaResponse",
        },
      ],
    },
  },
  required: ["id", "tenant", "config"],
} as const;

export const CredentialConfigCreateSchema = {
  type: "object",
  properties: {
    vct: {
      description:
        "VCT as a URI string (e.g., urn:eudi:pid:de:1) or as an object for EUDIPLO-hosted VCT",
      nullable: true,
      oneOf: [
        {
          type: "string",
          description: "VCT URI string",
        },
        {
          $ref: "#/components/schemas/VCT",
        },
      ],
    },
    embeddedDisclosurePolicy: {
      nullable: true,
      description:
        "Embedded disclosure policy (discriminated union by `policy`).\nThe discriminator makes class-transformer instantiate the right subclass,\nand then class-validator runs that subclass’s rules.",
      oneOf: [
        {
          $ref: "#/components/schemas/AttestationBasedPolicy",
        },
        {
          $ref: "#/components/schemas/NoneTrustPolicy",
        },
        {
          $ref: "#/components/schemas/AllowListPolicy",
        },
        {
          $ref: "#/components/schemas/RootOfTrustPolicy",
        },
      ],
      allOf: [
        {
          $ref: "#/components/schemas/EmbeddedDisclosurePolicy",
        },
      ],
    },
    id: {
      type: "string",
    },
    description: {
      type: "string",
      nullable: true,
    },
    config: {
      $ref: "#/components/schemas/IssuerMetadataCredentialConfig",
    },
    claims: {
      type: "object",
      nullable: true,
    },
    claimsWebhook: {
      nullable: true,
      description: "Webhook to receive claims for the issuance process.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    notificationWebhook: {
      nullable: true,
      description: "Webhook to receive claims for the issuance process.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    disclosureFrame: {
      type: "object",
      nullable: true,
    },
    keyBinding: {
      type: "boolean",
    },
    certId: {
      type: "string",
      description:
        "Reference to the certificate used for signing.\nNote: No DB-level FK constraint because CertEntity has a composite PK\n(id + tenantId) and SET NULL behavior cannot work when tenantId is\npart of this entity's own PK.",
    },
    statusManagement: {
      type: "boolean",
    },
    lifeTime: {
      type: "number",
    },
    schema: {
      nullable: true,
      allOf: [
        {
          $ref: "#/components/schemas/SchemaResponse",
        },
      ],
    },
  },
  required: ["id", "config"],
} as const;

export const CredentialConfigUpdateSchema = {
  type: "object",
  properties: {
    vct: {
      description:
        "VCT as a URI string (e.g., urn:eudi:pid:de:1) or as an object for EUDIPLO-hosted VCT",
      nullable: true,
      oneOf: [
        {
          type: "string",
          description: "VCT URI string",
        },
        {
          $ref: "#/components/schemas/VCT",
        },
      ],
    },
    embeddedDisclosurePolicy: {
      nullable: true,
      description:
        "Embedded disclosure policy (discriminated union by `policy`).\nThe discriminator makes class-transformer instantiate the right subclass,\nand then class-validator runs that subclass’s rules.",
      oneOf: [
        {
          $ref: "#/components/schemas/AttestationBasedPolicy",
        },
        {
          $ref: "#/components/schemas/NoneTrustPolicy",
        },
        {
          $ref: "#/components/schemas/AllowListPolicy",
        },
        {
          $ref: "#/components/schemas/RootOfTrustPolicy",
        },
      ],
      allOf: [
        {
          $ref: "#/components/schemas/EmbeddedDisclosurePolicy",
        },
      ],
    },
    id: {
      type: "string",
    },
    description: {
      type: "string",
      nullable: true,
    },
    config: {
      $ref: "#/components/schemas/IssuerMetadataCredentialConfig",
    },
    claims: {
      type: "object",
      nullable: true,
    },
    claimsWebhook: {
      nullable: true,
      description: "Webhook to receive claims for the issuance process.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    notificationWebhook: {
      nullable: true,
      description: "Webhook to receive claims for the issuance process.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    disclosureFrame: {
      type: "object",
      nullable: true,
    },
    keyBinding: {
      type: "boolean",
    },
    certId: {
      type: "string",
      description:
        "Reference to the certificate used for signing.\nNote: No DB-level FK constraint because CertEntity has a composite PK\n(id + tenantId) and SET NULL behavior cannot work when tenantId is\npart of this entity's own PK.",
    },
    statusManagement: {
      type: "boolean",
    },
    lifeTime: {
      type: "number",
    },
    schema: {
      nullable: true,
      allOf: [
        {
          $ref: "#/components/schemas/SchemaResponse",
        },
      ],
    },
  },
} as const;

export const DeferredCredentialRequestDtoSchema = {
  type: "object",
  properties: {
    transaction_id: {
      type: "string",
      description:
        "The transaction identifier previously returned by the Credential Endpoint",
      example: "8xLOxBtZp8",
    },
  },
  required: ["transaction_id"],
} as const;

export const NotificationRequestDtoSchema = {
  type: "object",
  properties: {
    notification_id: {
      type: "string",
    },
    event: {
      type: "object",
    },
  },
  required: ["notification_id", "event"],
} as const;

export const ParResponseDtoSchema = {
  type: "object",
  properties: {
    request_uri: {
      type: "string",
      description: "The request URI for the Pushed Authorization Request.",
    },
    expires_in: {
      type: "number",
      description: "The expiration time for the request URI in seconds.",
    },
  },
  required: ["request_uri", "expires_in"],
} as const;

export const OfferResponseSchema = {
  type: "object",
  properties: {
    uri: {
      type: "string",
    },
    crossDeviceUri: {
      type: "string",
      description: "URI for cross-device flows (no redirect after completion)",
    },
    session: {
      type: "string",
    },
  },
  required: ["uri", "session"],
} as const;

export const CompleteDeferredDtoSchema = {
  type: "object",
  properties: {},
} as const;

export const DeferredOperationResponseSchema = {
  type: "object",
  properties: {},
} as const;

export const FailDeferredDtoSchema = {
  type: "object",
  properties: {},
} as const;

export const EC_PublicSchema = {
  type: "object",
  properties: {
    kty: {
      type: "string",
      description:
        "The key type, which is always 'EC' for Elliptic Curve keys.",
    },
    crv: {
      type: "string",
      description:
        "The algorithm intended for use with the key, such as 'ES256'.",
    },
    x: {
      type: "string",
      description: "The x coordinate of the EC public key.",
    },
    y: {
      type: "string",
      description: "The y coordinate of the EC public key.",
    },
  },
  required: ["kty", "crv", "x", "y"],
} as const;

export const JwksResponseDtoSchema = {
  type: "object",
  properties: {
    keys: {
      description: "An array of EC public keys in JWK format.",
      type: "array",
      items: {
        $ref: "#/components/schemas/EC_Public",
      },
    },
  },
  required: ["keys"],
} as const;

export const AuthorizationResponseSchema = {
  type: "object",
  properties: {
    response: {
      type: "string",
      description: "The response string containing the authorization details.",
    },
    sendResponse: {
      type: "boolean",
      description:
        "When set to true, the authorization response will be sent to the client.",
    },
  },
  required: ["response"],
} as const;

export const RegistrarConfigEntitySchema = {
  type: "object",
  properties: {
    registrarUrl: {
      type: "string",
      description: "The base URL of the registrar API",
      format: "uri",
      example: "https://sandbox.eudi-wallet.org/api",
    },
    oidcUrl: {
      type: "string",
      description:
        "The OIDC issuer URL for authentication (e.g., Keycloak realm URL)",
      format: "uri",
      example: "https://auth.example.com/realms/my-realm",
    },
    clientId: {
      type: "string",
      description: "The OIDC client ID for the registrar",
      example: "registrar-client",
    },
    clientSecret: {
      type: "string",
      description:
        "The OIDC client secret (optional, for confidential clients)",
    },
    username: {
      type: "string",
      description: "The username for OIDC login",
      example: "admin@example.com",
    },
    password: {
      type: "string",
      description: "The password for OIDC login (stored in plaintext)",
    },
    tenantId: {
      type: "string",
      description: "The tenant ID this configuration belongs to.",
    },
    tenant: {
      description: "The tenant that owns this configuration.",
      allOf: [
        {
          $ref: "#/components/schemas/TenantEntity",
        },
      ],
    },
  },
  required: [
    "registrarUrl",
    "oidcUrl",
    "clientId",
    "username",
    "password",
    "tenantId",
    "tenant",
  ],
} as const;

export const CreateRegistrarConfigDtoSchema = {
  type: "object",
  properties: {
    registrarUrl: {
      type: "string",
      description: "The base URL of the registrar API",
      format: "uri",
      example: "https://sandbox.eudi-wallet.org/api",
    },
    oidcUrl: {
      type: "string",
      description:
        "The OIDC issuer URL for authentication (e.g., Keycloak realm URL)",
      format: "uri",
      example: "https://auth.example.com/realms/my-realm",
    },
    clientId: {
      type: "string",
      description: "The OIDC client ID for the registrar",
      example: "registrar-client",
    },
    clientSecret: {
      type: "string",
      description:
        "The OIDC client secret (optional, for confidential clients)",
    },
    username: {
      type: "string",
      description: "The username for OIDC login",
      example: "admin@example.com",
    },
    password: {
      type: "string",
      description: "The password for OIDC login (stored in plaintext)",
    },
  },
  required: ["registrarUrl", "oidcUrl", "clientId", "username", "password"],
} as const;

export const UpdateRegistrarConfigDtoSchema = {
  type: "object",
  properties: {
    registrarUrl: {
      type: "string",
      description: "The base URL of the registrar API",
      format: "uri",
      example: "https://sandbox.eudi-wallet.org/api",
    },
    oidcUrl: {
      type: "string",
      description:
        "The OIDC issuer URL for authentication (e.g., Keycloak realm URL)",
      format: "uri",
      example: "https://auth.example.com/realms/my-realm",
    },
    clientId: {
      type: "string",
      description: "The OIDC client ID for the registrar",
      example: "registrar-client",
    },
    clientSecret: {
      type: "string",
      description:
        "The OIDC client secret (optional, for confidential clients)",
    },
    username: {
      type: "string",
      description: "The username for OIDC login",
      example: "admin@example.com",
    },
    password: {
      type: "string",
      description: "The password for OIDC login (stored in plaintext)",
    },
  },
} as const;

export const CreateAccessCertificateDtoSchema = {
  type: "object",
  properties: {
    keyId: {
      type: "string",
      description: "The ID of the key to create an access certificate for",
      example: "my-signing-key",
    },
  },
  required: ["keyId"],
} as const;

export const DCQLSchema = {
  type: "object",
  properties: {
    credentials: {
      type: "array",
      items: {
        $ref: "#/components/schemas/CredentialQuery",
      },
    },
    credential_sets: {
      type: "array",
      items: {
        $ref: "#/components/schemas/CredentialSetQuery",
      },
    },
  },
  required: ["credentials"],
} as const;

export const RegistrationCertificateRequestSchema = {
  type: "object",
  properties: {
    jwt: {
      type: "string",
      description:
        "The body of the registration certificate request containing the necessary details.",
    },
  },
  required: ["jwt"],
} as const;

export const PresentationAttachmentSchema = {
  type: "object",
  properties: {
    format: {
      type: "string",
    },
    data: {
      type: "object",
    },
    credential_ids: {
      type: "array",
      items: {
        type: "string",
      },
    },
  },
  required: ["format", "data"],
} as const;

export const PresentationConfigSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the VP request.",
    },
    tenant: {
      description: "The tenant that owns this object.",
      allOf: [
        {
          $ref: "#/components/schemas/TenantEntity",
        },
      ],
    },
    description: {
      type: "string",
      nullable: true,
      description: "Description of the presentation configuration.",
    },
    lifeTime: {
      type: "number",
      description:
        "Lifetime how long the presentation request is valid after creation, in seconds.",
    },
    dcql_query: {
      description: "The DCQL query to be used for the VP request.",
      allOf: [
        {
          $ref: "#/components/schemas/DCQL",
        },
      ],
    },
    transaction_data: {
      type: "array",
      items: {
        $ref: "#/components/schemas/TransactionData",
      },
    },
    registrationCert: {
      nullable: true,
      description:
        "The registration certificate request containing the necessary details.",
      allOf: [
        {
          $ref: "#/components/schemas/RegistrationCertificateRequest",
        },
      ],
    },
    webhook: {
      nullable: true,
      description: "Optional webhook URL to receive the response.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    createdAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the VP request was created.",
    },
    updatedAt: {
      format: "date-time",
      type: "string",
      description: "The timestamp when the VP request was last updated.",
    },
    attached: {
      nullable: true,
      description: "Attestation that should be attached",
      type: "array",
      items: {
        $ref: "#/components/schemas/PresentationAttachment",
      },
    },
    redirectUri: {
      type: "string",
      nullable: true,
      description:
        "Redirect URI to which the user-agent should be redirected after the presentation is completed.\nYou can use the `{sessionId}` placeholder in the URI, which will be replaced with the actual session ID.",
      example: "https://example.com/callback?session={sessionId}",
    },
    accessCertId: {
      type: "string",
      nullable: true,
      description:
        "Optional ID of the access certificate to use for signing the presentation request.\nIf not provided, the default access certificate for the tenant will be used.\n\nNote: This is intentionally NOT a TypeORM relationship because CertEntity uses\na composite primary key (id + tenantId), and SQLite cannot create foreign keys\nthat reference only part of a composite primary key. The relationship is handled\nat the application level in the service layer.",
    },
  },
  required: ["id", "tenant", "dcql_query", "createdAt", "updatedAt"],
} as const;

export const PresentationConfigCreateDtoSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the VP request.",
    },
    description: {
      type: "string",
      nullable: true,
      description: "Description of the presentation configuration.",
    },
    lifeTime: {
      type: "number",
      description:
        "Lifetime how long the presentation request is valid after creation, in seconds.",
    },
    dcql_query: {
      description: "The DCQL query to be used for the VP request.",
      allOf: [
        {
          $ref: "#/components/schemas/DCQL",
        },
      ],
    },
    transaction_data: {
      type: "array",
      items: {
        $ref: "#/components/schemas/TransactionData",
      },
    },
    registrationCert: {
      nullable: true,
      description:
        "The registration certificate request containing the necessary details.",
      allOf: [
        {
          $ref: "#/components/schemas/RegistrationCertificateRequest",
        },
      ],
    },
    webhook: {
      nullable: true,
      description: "Optional webhook URL to receive the response.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    attached: {
      nullable: true,
      description: "Attestation that should be attached",
      type: "array",
      items: {
        $ref: "#/components/schemas/PresentationAttachment",
      },
    },
    redirectUri: {
      type: "string",
      nullable: true,
      description:
        "Redirect URI to which the user-agent should be redirected after the presentation is completed.\nYou can use the `{sessionId}` placeholder in the URI, which will be replaced with the actual session ID.",
      example: "https://example.com/callback?session={sessionId}",
    },
    accessCertId: {
      type: "string",
      nullable: true,
      description:
        "Optional ID of the access certificate to use for signing the presentation request.\nIf not provided, the default access certificate for the tenant will be used.\n\nNote: This is intentionally NOT a TypeORM relationship because CertEntity uses\na composite primary key (id + tenantId), and SQLite cannot create foreign keys\nthat reference only part of a composite primary key. The relationship is handled\nat the application level in the service layer.",
    },
  },
  required: ["id", "dcql_query"],
} as const;

export const PresentationConfigUpdateDtoSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the VP request.",
    },
    description: {
      type: "string",
      nullable: true,
      description: "Description of the presentation configuration.",
    },
    lifeTime: {
      type: "number",
      description:
        "Lifetime how long the presentation request is valid after creation, in seconds.",
    },
    dcql_query: {
      description: "The DCQL query to be used for the VP request.",
      allOf: [
        {
          $ref: "#/components/schemas/DCQL",
        },
      ],
    },
    transaction_data: {
      type: "array",
      items: {
        $ref: "#/components/schemas/TransactionData",
      },
    },
    registrationCert: {
      nullable: true,
      description:
        "The registration certificate request containing the necessary details.",
      allOf: [
        {
          $ref: "#/components/schemas/RegistrationCertificateRequest",
        },
      ],
    },
    webhook: {
      nullable: true,
      description: "Optional webhook URL to receive the response.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    attached: {
      nullable: true,
      description: "Attestation that should be attached",
      type: "array",
      items: {
        $ref: "#/components/schemas/PresentationAttachment",
      },
    },
    redirectUri: {
      type: "string",
      nullable: true,
      description:
        "Redirect URI to which the user-agent should be redirected after the presentation is completed.\nYou can use the `{sessionId}` placeholder in the URI, which will be replaced with the actual session ID.",
      example: "https://example.com/callback?session={sessionId}",
    },
    accessCertId: {
      type: "string",
      nullable: true,
      description:
        "Optional ID of the access certificate to use for signing the presentation request.\nIf not provided, the default access certificate for the tenant will be used.\n\nNote: This is intentionally NOT a TypeORM relationship because CertEntity uses\na composite primary key (id + tenantId), and SQLite cannot create foreign keys\nthat reference only part of a composite primary key. The relationship is handled\nat the application level in the service layer.",
    },
  },
} as const;

export const TrustListCreateDtoSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
    },
    certId: {
      type: "string",
    },
    entities: {
      type: "array",
      items: {
        type: "object",
      },
    },
    description: {
      type: "string",
    },
    data: {
      type: "object",
      description: "The full trust list JSON (generated LoTE structure)",
    },
  },
  required: ["entities"],
} as const;

export const TrustListSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
      description: "Unique identifier for the trust list",
    },
    description: {
      type: "string",
    },
    tenantId: {
      type: "string",
      description: "The tenant ID for which the VP request is made.",
    },
    tenant: {
      description: "The tenant that owns this object.",
      allOf: [
        {
          $ref: "#/components/schemas/TenantEntity",
        },
      ],
    },
    certId: {
      type: "string",
    },
    cert: {
      $ref: "#/components/schemas/CertEntity",
    },
    data: {
      type: "object",
      description: "The full trust list JSON (generated LoTE structure)",
    },
    entityConfig: {
      description:
        "The original entity configuration used to create this trust list.\nStored for round-tripping when editing.",
      type: "array",
      items: {
        type: "object",
      },
    },
    sequenceNumber: {
      type: "number",
      description:
        "The sequence number for versioning (incremented on updates)",
    },
    jwt: {
      type: "string",
      description: "The signed JWT representation of this trust list",
    },
    createdAt: {
      format: "date-time",
      type: "string",
    },
    updatedAt: {
      format: "date-time",
      type: "string",
    },
  },
  required: [
    "id",
    "tenantId",
    "tenant",
    "certId",
    "cert",
    "sequenceNumber",
    "jwt",
    "createdAt",
    "updatedAt",
  ],
} as const;

export const TrustListVersionSchema = {
  type: "object",
  properties: {
    id: {
      type: "string",
    },
    trustListId: {
      type: "string",
    },
    trustList: {
      $ref: "#/components/schemas/TrustList",
    },
    tenantId: {
      type: "string",
    },
    sequenceNumber: {
      type: "number",
      description: "The sequence number at the time this version was created",
    },
    data: {
      type: "object",
      description: "The full trust list JSON at this version",
    },
    entityConfig: {
      type: "object",
      description: "The entity configuration at this version",
    },
    jwt: {
      type: "string",
      description: "The signed JWT at this version",
    },
    createdAt: {
      format: "date-time",
      type: "string",
    },
  },
  required: [
    "id",
    "trustListId",
    "trustList",
    "tenantId",
    "sequenceNumber",
    "data",
    "jwt",
    "createdAt",
  ],
} as const;

export const PresentationRequestSchema = {
  type: "object",
  properties: {
    response_type: {
      type: "string",
      description:
        "The type of response expected from the presentation request.",
      enum: ["qrcode", "uri", "dc-api"],
    },
    requestId: {
      type: "string",
      description: "Identifier of the presentation configuration",
    },
    webhook: {
      description:
        "Webhook configuration to receive the response.\nIf not provided, the configured webhook from the configuration will be used.",
      allOf: [
        {
          $ref: "#/components/schemas/WebhookConfig",
        },
      ],
    },
    redirectUri: {
      type: "string",
      description:
        "Optional redirect URI to which the user-agent should be redirected after the presentation is completed.\nYou can use the `{sessionId}` placeholder in the URI, which will be replaced with the actual session ID.",
      example: "https://example.com/callback?session={sessionId}",
    },
    transaction_data: {
      description:
        "Optional transaction data to include in the OID4VP request.\nIf provided, this will override the transaction_data from the presentation configuration.",
      type: "array",
      items: {
        $ref: "#/components/schemas/TransactionData",
      },
    },
  },
  required: ["response_type", "requestId"],
} as const;

export const FileUploadDtoSchema = {
  type: "object",
  properties: {
    file: {
      type: "string",
      format: "binary",
    },
  },
  required: ["file"],
} as const;
