// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: string;
};

export type RoleDto = {
  /**
   * OAuth2 roles
   */
  role:
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage";
};

export type ClientCredentialsDto = {
  grant_type?: string;
  client_id: string;
  client_secret: string;
};

export type TokenResponse = {
  access_token: string;
  refresh_token?: string;
  token_type: string;
  expires_in: number;
};

export type ImportTenantDto = {
  /**
   * The name of the tenant.
   */
  name: string;
  /**
   * The description of the tenant.
   */
  description?: string;
};

export type SessionStorageConfig = {
  /**
   * Time-to-live for sessions in seconds. If not set, uses global SESSION_TTL.
   */
  ttlSeconds?: number;
  /**
   * Cleanup mode: 'full' deletes everything, 'anonymize' keeps metadata but removes PII.
   */
  cleanupMode?: "full" | "anonymize";
};

export type StatusListConfig = {
  /**
   * The capacity of the status list. If not set, uses global STATUS_CAPACITY.
   */
  capacity?: number;
  /**
   * Bits per status entry: 1 (valid/revoked), 2 (with suspended), 4/8 (extended). If not set, uses global STATUS_BITS.
   */
  bits?: 1 | 2 | 4 | 8;
  /**
   * TTL in seconds for the status list JWT. If not set, uses global STATUS_TTL.
   */
  ttl?: number;
  /**
   * If true, regenerate JWT immediately on status changes. If false (default), use lazy regeneration on TTL expiry.
   */
  immediateUpdate?: boolean;
  /**
   * If true, include aggregation_uri in status list JWTs for pre-fetching support (default: true).
   */
  enableAggregation?: boolean;
};

export type TenantEntity = {
  /**
   * Session storage configuration for this tenant. Controls TTL and cleanup behavior.
   */
  sessionConfig?: SessionStorageConfig;
  /**
   * Status list configuration for this tenant. Only affects newly created status lists.
   */
  statusListConfig?: StatusListConfig;
  /**
   * The unique identifier for the tenant.
   */
  id: string;
  /**
   * The name of the tenant.
   */
  name: string;
  /**
   * The description of the tenant.
   */
  description?: string;
  /**
   * The current status of the tenant.
   */
  status: string;
  /**
   * The clients associated with the tenant.
   */
  clients: Array<ClientEntity>;
};

export type ClientEntity = {
  /**
   * The unique identifier for the client.
   */
  clientId: string;
  /**
   * The secret key for the client.
   */
  secret?: string;
  /**
   * The unique identifier for the tenant that the client belongs to. Only null for accounts that manage tenants, that do not belong to a client
   */
  tenantId?: string;
  /**
   * The description of the client.
   */
  description?: string;
  /**
   * The roles assigned to the client.
   */
  roles: Array<
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage"
  >;
  /**
   * The tenant that the client belongs to.
   */
  tenant?: TenantEntity;
};

export type CreateTenantDto = {
  /**
   * Status list configuration for this tenant. Only affects newly created status lists.
   */
  statusListConfig?: StatusListConfig;
  /**
   * Session storage configuration. Controls TTL and cleanup behavior.
   */
  sessionConfig?: SessionStorageConfig;
  roles?: Array<
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage"
  >;
  /**
   * The unique identifier for the tenant.
   */
  id: string;
  /**
   * The name of the tenant.
   */
  name: string;
  /**
   * The description of the tenant.
   */
  description?: string;
};

export type UpdateTenantDto = {
  /**
   * Status list configuration for this tenant. Only affects newly created status lists.
   */
  statusListConfig?: StatusListConfig;
  /**
   * Session storage configuration. Controls TTL and cleanup behavior.
   */
  sessionConfig?: SessionStorageConfig;
  /**
   * The name of the tenant.
   */
  name?: string;
  /**
   * The description of the tenant.
   */
  description?: string;
  roles?: Array<
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage"
  >;
};

export type ClientSecretResponseDto = {
  secret: string;
};

export type UpdateClientDto = {
  /**
   * The description of the client.
   */
  description?: string;
  /**
   * The roles assigned to the client.
   */
  roles: Array<
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage"
  >;
};

export type CreateClientDto = {
  /**
   * The unique identifier for the client.
   */
  clientId: string;
  /**
   * The secret key for the client.
   */
  secret?: string;
  /**
   * The description of the client.
   */
  description?: string;
  /**
   * The roles assigned to the client.
   */
  roles: Array<
    | "presentation:manage"
    | "presentation:offer"
    | "issuance:manage"
    | "issuance:offer"
    | "clients:manage"
    | "tenants:manage"
  >;
};

export type CertUsageEntity = {
  tenantId: string;
  certId: string;
  usage: "access" | "signing" | "trustList" | "statusList";
  cert: CertEntity;
};

export type KeyEntity = {
  /**
   * Unique identifier for the key.
   */
  id: string;
  /**
   * Description of the key.
   */
  description?: string;
  /**
   * Tenant ID for the key.
   */
  tenantId: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  /**
   * The key material.
   */
  key: {
    [key: string]: unknown;
  };
  /**
   * The usage type of the key.
   */
  usage: {
    [key: string]: unknown;
  };
  /**
   * Certificates associated with this key.
   */
  certificates: Array<CertEntity>;
  /**
   * The timestamp when the key was created.
   */
  createdAt: string;
  /**
   * The timestamp when the key was last updated.
   */
  updatedAt: string;
};

export type CertEntity = {
  /**
   * The key ID this certificate is associated with
   */
  keyId: string;
  /**
   * Unique identifier for the key.
   */
  id: string;
  /**
   * Tenant ID for the key.
   */
  tenantId: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  /**
   * Certificate in PEM format.
   */
  crt: string;
  usages: Array<CertUsageEntity>;
  /**
   * Description of the key.
   */
  description?: string;
  key: KeyEntity;
  /**
   * The timestamp when the certificate was created.
   */
  createdAt: string;
  /**
   * The timestamp when the certificate was last updated.
   */
  updatedAt: string;
};

export type Key = {
  kty: string;
  x: string;
  y: string;
  crv: string;
  d: string;
  alg: string;
};

export type KeyImportDto = {
  /**
   * The private key in JWK format.
   */
  key: Key;
  /**
   * Unique identifier for the key.
   */
  id: string;
  /**
   * Description of the key.
   */
  description?: string;
};

export type UpdateKeyDto = {
  /**
   * Unique identifier for the key.
   */
  id: string;
  /**
   * Description of the key.
   */
  description?: string;
};

export type CertImportDto = {
  /**
   * The key ID this certificate is associated with
   */
  keyId: string;
  id?: string;
  /**
   * Usage types for the certificate.
   */
  certUsageTypes: Array<"access" | "signing" | "trustList" | "statusList">;
  /**
   * Certificate in PEM format, if not provided, a self-signed certificate will be generated.
   */
  crt?: string;
  /**
   * Subject name (CN) for self-signed certificate generation.
   * If not provided, the tenant name will be used.
   */
  subjectName?: string;
  /**
   * Description of the key.
   */
  description?: string;
};

export type CertResponseDto = {
  /**
   * The ID of the created self-signed certificate.
   */
  id: string;
};

export type CertUpdateDto = {
  /**
   * Usage types for the certificate.
   */
  certUsageTypes: Array<"access" | "signing" | "trustList" | "statusList">;
  usages: Array<CertUsageEntity>;
  /**
   * Description of the key.
   */
  description?: string;
};

export type StatusListImportDto = {
  /**
   * Unique identifier for the status list
   */
  id: string;
  /**
   * Credential configuration ID to bind this list exclusively to. Leave empty for a shared list.
   */
  credentialConfigurationId?: string;
  /**
   * Certificate ID to use for signing. Leave empty to use the tenant's default StatusList certificate.
   */
  certId?: string;
  /**
   * Capacity of the status list. If not provided, uses tenant or global defaults.
   */
  capacity?: number;
  /**
   * Bits per status value. If not provided, uses tenant or global defaults.
   */
  bits?: 1 | 2 | 4 | 8;
};

export type StatusListAggregationDto = {
  /**
   * Array of status list token URIs
   */
  status_lists: Array<string>;
};

export type UpdateStatusListConfigDto = {
  /**
   * The capacity of the status list. Set to null to reset to global default.
   */
  capacity?: number;
  /**
   * Bits per status entry. Set to null to reset to global default.
   */
  bits?: 1 | 2 | 4 | 8;
  /**
   * TTL in seconds for the status list JWT. Set to null to reset to global default.
   */
  ttl?: number;
  /**
   * If true, regenerate JWT on every status change. Set to null to reset to default (false).
   */
  immediateUpdate?: boolean;
  /**
   * If true, include aggregation_uri in status list JWTs for pre-fetching support. Set to null to reset to default (true).
   */
  enableAggregation?: boolean;
};

export type StatusListResponseDto = {
  /**
   * Unique identifier for the status list
   */
  id: string;
  /**
   * The tenant ID
   */
  tenantId: string;
  /**
   * Credential configuration ID this list is bound to. Null means shared.
   */
  credentialConfigurationId?: string;
  /**
   * Certificate ID used for signing. Null means using the tenant's default.
   */
  certId?: string;
  /**
   * Bits per status value
   */
  bits: 1 | 2 | 4 | 8;
  /**
   * Total capacity of the status list
   */
  capacity: number;
  /**
   * Number of entries in use
   */
  usedEntries: number;
  /**
   * Number of available entries
   */
  availableEntries: number;
  /**
   * The public URI for this status list
   */
  uri: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * JWT expiration timestamp. Null if JWT has not been generated yet.
   */
  expiresAt?: string;
};

export type CreateStatusListDto = {
  /**
   * Credential configuration ID to bind this list exclusively to. Leave empty for a shared list.
   */
  credentialConfigurationId?: string;
  /**
   * Certificate ID to use for signing. Leave empty to use the tenant's default StatusList certificate.
   */
  certId?: string;
  /**
   * Bits per status value. More bits allow more status states. Defaults to tenant configuration.
   */
  bits?: 1 | 2 | 4 | 8;
  /**
   * Maximum number of credential status entries. Defaults to tenant configuration.
   */
  capacity?: number;
};

export type UpdateStatusListDto = {
  /**
   * Credential configuration ID to bind this list exclusively to. Set to null to make this a shared list.
   */
  credentialConfigurationId?: string;
  /**
   * Certificate ID to use for signing. Set to null to use the tenant's default StatusList certificate.
   */
  certId?: string;
};

export type AuthorizeQueries = {
  issuer_state?: string;
  response_type?: string;
  client_id?: string;
  redirect_uri?: string;
  resource?: string;
  scope?: string;
  code_challenge?: string;
  code_challenge_method?: string;
  dpop_jkt?: string;
  request_uri?: string;
  auth_session?: string;
  state?: string;
};

export type WebHookAuthConfigNone = {
  /**
   * The type of authentication used for the webhook.
   */
  type: "none";
};

export type ApiKeyConfig = {
  /**
   * The name of the header where the API key will be sent.
   */
  headerName: string;
  /**
   * The value of the API key to be sent in the header.
   */
  value: string;
};

export type WebHookAuthConfigHeader = {
  /**
   * The type of authentication used for the webhook.
   */
  type: "apiKey";
  /**
   * Configuration for API key authentication.
   * This is required if the type is 'apiKey'.
   */
  config: ApiKeyConfig;
};

export type WebhookConfig = {
  /**
   * Optional authentication configuration for the webhook.
   * If not provided, no authentication will be used.
   */
  auth: WebHookAuthConfigNone | WebHookAuthConfigHeader;
  /**
   * The URL to which the webhook will send notifications.
   */
  url: string;
};

export type OfferRequestDto = {
  /**
   * The type of response expected for the offer request.
   */
  response_type: "qrcode" | "uri" | "dc-api";
  /**
   * Credential claims configuration per credential. Keys must match credentialConfigurationIds.
   */
  credentialClaims?: {
    additionalProperties?:
      | {
          type: "inline";
          claims: {
            [key: string]: unknown;
          };
        }
      | {
          type: "webhook";
          webhook: {
            [key: string]: unknown;
          };
        };
  };
  /**
   * The flow type for the offer request.
   */
  flow: "authorization_code" | "pre_authorized_code";
  /**
   * Transaction code for pre-authorized code flow.
   */
  tx_code?: string;
  /**
   * List of credential configuration ids to be included in the offer.
   */
  credentialConfigurationIds: Array<string>;
  /**
   * Webhook to notify about the status of the issuance process.
   */
  notifyWebhook?: WebhookConfig;
};

export type Session = {
  /**
   * Status of the session.
   */
  status: "active" | "fetched" | "completed" | "expired" | "failed";
  /**
   * Unique identifier for the session.
   */
  id: string;
  /**
   * The timestamp when the request was created.
   */
  createdAt: string;
  /**
   * The timestamp when the request was last updated.
   */
  updatedAt: string;
  /**
   * The timestamp when the request is set to expire.
   */
  expiresAt?: string;
  /**
   * Flag indicating whether to use the DC API for the presentation request.
   */
  useDcApi: boolean;
  /**
   * Tenant ID for multi-tenancy support.
   */
  tenantId: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  authorization_code?: string;
  /**
   * Request URI from the authorization request.
   */
  request_uri?: string;
  /**
   * Authorization queries associated with the session.
   */
  auth_queries?: AuthorizeQueries;
  /**
   * Credential offer object containing details about the credential offer or presentation request.
   */
  offer?: {
    [key: string]: unknown;
  };
  /**
   * Offer URL for the credential offer.
   */
  offerUrl?: string;
  /**
   * Credential payload containing the offer request details.
   */
  credentialPayload?: OfferRequestDto;
  /**
   * Webhook configuration to send the result of the notification response.
   */
  notifyWebhook?: WebhookConfig;
  /**
   * Notifications associated with the session.
   */
  notifications: Array<{
    [key: string]: unknown;
  }>;
  requestId?: string;
  /**
   * The URL of the presentation auth request.
   */
  requestUrl?: string;
  /**
   * Signed presentation auth request.
   */
  requestObject?: string;
  /**
   * Verified credentials from the presentation process.
   */
  credentials?: Array<{
    [key: string]: unknown;
  }>;
  /**
   * Noncce from the Verifiable Presentation request.
   */
  vp_nonce?: string;
  /**
   * Client ID used in the OID4VP authorization request.
   */
  clientId?: string;
  /**
   * Response URI used in the OID4VP authorization request.
   */
  responseUri?: string;
  /**
   * Redirect URI to which the user-agent should be redirected after the presentation is completed.
   */
  redirectUri?: string;
  /**
   * Where to send the claims webhook response.
   */
  parsedWebhook?: WebhookConfig;
};

export type StatusUpdateDto = {
  /**
   * The session ID of the user
   */
  sessionId: string;
  /**
   * The ID of the credential configuration
   * This is optional, if not provided, all credentials will be revoked of the session.
   */
  credentialConfigurationId?: string;
  /**
   * The status of the credential
   * 0 = valid, 1 = revoked, 2 = suspended
   */
  status: number;
};

export type UpdateSessionConfigDto = {
  /**
   * Time-to-live for sessions in seconds. Set to null to use global default.
   */
  ttlSeconds?: number;
  /**
   * Cleanup mode: 'full' deletes everything, 'anonymize' keeps metadata but removes PII.
   */
  cleanupMode?: "full" | "anonymize";
};

export type AuthenticationMethodNone = {
  method: "none";
};

export type AuthenticationUrlConfig = {
  /**
   * The URL used in the OID4VCI authorized code flow.
   * This URL is where users will be redirected for authentication.
   */
  url: string;
  /**
   * Optional webhook configuration for authentication callbacks
   */
  webhook?: WebhookConfig;
};

export type AuthenticationMethodAuth = {
  method: "auth";
  config: AuthenticationUrlConfig;
};

export type PresentationDuringIssuanceConfig = {
  /**
   * Link to the presentation configuration that is relevant for the issuance process
   */
  type: string;
};

export type AuthenticationMethodPresentation = {
  method: "presentationDuringIssuance";
  config: PresentationDuringIssuanceConfig;
};

export type DisplayLogo = {
  uri: string;
  alt_text?: string;
};

export type DisplayInfo = {
  name?: string;
  locale?: string;
  logo?: DisplayLogo;
};

export type IssuanceConfig = {
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  /**
   * Authentication server URL for the issuance process.
   */
  authServers?: Array<string>;
  /**
   * Value to determine the amount of credentials that are issued in a batch.
   * Default is 1.
   */
  batchSize?: number;
  /**
   * Indicates whether DPoP is required for the issuance process. Default value is true.
   */
  dPopRequired?: boolean;
  display: Array<DisplayInfo>;
  /**
   * The timestamp when the VP request was created.
   */
  createdAt: string;
  /**
   * The timestamp when the VP request was last updated.
   */
  updatedAt: string;
};

export type IssuanceDto = {
  /**
   * Authentication server URL for the issuance process.
   */
  authServers?: Array<string>;
  /**
   * Value to determine the amount of credentials that are issued in a batch.
   * Default is 1.
   */
  batchSize?: number;
  /**
   * Indicates whether DPoP is required for the issuance process. Default value is true.
   */
  dPopRequired?: boolean;
  display: Array<DisplayInfo>;
};

export type ClaimsQuery = {
  id: string;
  path: Array<string>;
  values?: Array<{
    [key: string]: unknown;
  }>;
};

export type Claim = {
  path: Array<string>;
};

export type TrustedAuthorityQuery = {
  type: "aki" | "etsi_tl";
  values: Array<string>;
};

export type CredentialQuery = {
  id: string;
  format: string;
  multiple?: boolean;
  claims?: Array<Claim>;
  meta: {
    [key: string]: unknown;
  };
  trusted_authorities?: Array<TrustedAuthorityQuery>;
};

export type CredentialSetQuery = {
  options: Array<Array<string>>;
  required?: boolean;
};

export type PolicyCredential = {
  claims?: Array<ClaimsQuery>;
  credentials: Array<CredentialQuery>;
  credential_sets?: Array<CredentialSetQuery>;
};

export type AttestationBasedPolicy = {
  policy: "attestationBased";
  values: Array<PolicyCredential>;
};

export type NoneTrustPolicy = {
  policy: "none";
};

export type AllowListPolicy = {
  policy: "allowList";
  values: Array<string>;
};

export type RootOfTrustPolicy = {
  policy: "rootOfTrust";
  values: string;
};

export type Vct = {
  vct?: string;
  name?: string;
  description?: string;
  extends?: string;
  "extends#integrity"?: string;
  schema_uri?: string;
  "schema_uri#integrity"?: string;
};

export type EmbeddedDisclosurePolicy = {
  policy: string;
};

export type DisplayImage = {
  uri: string;
};

export type Display = {
  name: string;
  description: string;
  locale: string;
  background_color?: string;
  text_color?: string;
  background_image?: DisplayImage;
  logo?: DisplayImage;
};

export type IssuerMetadataCredentialConfig = {
  format: string;
  display: Array<Display>;
  scope?: string;
  /**
   * Document type for mDOC credentials (e.g., "org.iso.18013.5.1.mDL").
   * Only applicable when format is "mso_mdoc".
   */
  docType?: string;
  /**
   * Namespace for mDOC credentials (e.g., "org.iso.18013.5.1").
   * Only applicable when format is "mso_mdoc".
   * Used when claims are provided as a flat object.
   */
  namespace?: string;
  /**
   * Claims organized by namespace for mDOC credentials.
   * Allows specifying claims across multiple namespaces.
   * Only applicable when format is "mso_mdoc".
   * Example:
   * {
   * "org.iso.18013.5.1": { "given_name": "John", "family_name": "Doe" },
   * "org.iso.18013.5.1.aamva": { "DHS_compliance": "F" }
   * }
   */
  claimsByNamespace?: {
    [key: string]: unknown;
  };
};

export type SchemaResponse = {
  $schema: string;
  type: string;
  properties: {
    [key: string]: unknown;
  };
  required?: Array<string>;
  title?: string;
  description?: string;
};

export type CredentialConfig = {
  /**
   * VCT as a URI string (e.g., urn:eudi:pid:de:1) or as an object for EUDIPLO-hosted VCT
   */
  vct?: string | Vct;
  /**
   * Embedded disclosure policy (discriminated union by `policy`).
   * The discriminator makes class-transformer instantiate the right subclass,
   * and then class-validator runs that subclass’s rules.
   */
  embeddedDisclosurePolicy?: EmbeddedDisclosurePolicy;
  id: string;
  description?: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  config: IssuerMetadataCredentialConfig;
  claims?: {
    [key: string]: unknown;
  };
  /**
   * Webhook to receive claims for the issuance process.
   */
  claimsWebhook?: WebhookConfig;
  /**
   * Webhook to receive claims for the issuance process.
   */
  notificationWebhook?: WebhookConfig;
  disclosureFrame?: {
    [key: string]: unknown;
  };
  keyBinding?: boolean;
  certId?: string;
  cert: CertEntity;
  statusManagement?: boolean;
  lifeTime?: number;
  schema?: SchemaResponse;
};

export type CredentialConfigCreate = {
  /**
   * VCT as a URI string (e.g., urn:eudi:pid:de:1) or as an object for EUDIPLO-hosted VCT
   */
  vct?: string | Vct;
  /**
   * Embedded disclosure policy (discriminated union by `policy`).
   * The discriminator makes class-transformer instantiate the right subclass,
   * and then class-validator runs that subclass’s rules.
   */
  embeddedDisclosurePolicy?: EmbeddedDisclosurePolicy;
  id: string;
  description?: string;
  config: IssuerMetadataCredentialConfig;
  claims?: {
    [key: string]: unknown;
  };
  /**
   * Webhook to receive claims for the issuance process.
   */
  claimsWebhook?: WebhookConfig;
  /**
   * Webhook to receive claims for the issuance process.
   */
  notificationWebhook?: WebhookConfig;
  disclosureFrame?: {
    [key: string]: unknown;
  };
  keyBinding?: boolean;
  certId?: string;
  statusManagement?: boolean;
  lifeTime?: number;
  schema?: SchemaResponse;
};

export type CredentialConfigUpdate = {
  /**
   * VCT as a URI string (e.g., urn:eudi:pid:de:1) or as an object for EUDIPLO-hosted VCT
   */
  vct?: string | Vct;
  /**
   * Embedded disclosure policy (discriminated union by `policy`).
   * The discriminator makes class-transformer instantiate the right subclass,
   * and then class-validator runs that subclass’s rules.
   */
  embeddedDisclosurePolicy?: EmbeddedDisclosurePolicy;
  id?: string;
  description?: string;
  config?: IssuerMetadataCredentialConfig;
  claims?: {
    [key: string]: unknown;
  };
  /**
   * Webhook to receive claims for the issuance process.
   */
  claimsWebhook?: WebhookConfig;
  /**
   * Webhook to receive claims for the issuance process.
   */
  notificationWebhook?: WebhookConfig;
  disclosureFrame?: {
    [key: string]: unknown;
  };
  keyBinding?: boolean;
  certId?: string;
  statusManagement?: boolean;
  lifeTime?: number;
  schema?: SchemaResponse;
};

export type NotificationRequestDto = {
  notification_id: string;
  event: {
    [key: string]: unknown;
  };
};

export type ParResponseDto = {
  /**
   * The request URI for the Pushed Authorization Request.
   */
  request_uri: string;
  /**
   * The expiration time for the request URI in seconds.
   */
  expires_in: number;
};

export type OfferResponse = {
  uri: string;
  session: string;
};

export type EcPublic = {
  /**
   * The key type, which is always 'EC' for Elliptic Curve keys.
   */
  kty: string;
  /**
   * The algorithm intended for use with the key, such as 'ES256'.
   */
  crv: string;
  /**
   * The x coordinate of the EC public key.
   */
  x: string;
  /**
   * The y coordinate of the EC public key.
   */
  y: string;
};

export type JwksResponseDto = {
  /**
   * An array of EC public keys in JWK format.
   */
  keys: Array<EcPublic>;
};

export type AuthorizationResponse = {
  /**
   * The response string containing the authorization details.
   */
  response: string;
  /**
   * When set to true, the authorization response will be sent to the client.
   */
  sendResponse?: boolean;
};

export type Dcql = {
  credentials: Array<CredentialQuery>;
  credential_sets?: Array<CredentialSetQuery>;
};

export type RegistrationCertificateRequest = {
  /**
   * The body of the registration certificate request containing the necessary details.
   */
  jwt: string;
};

export type PresentationAttachment = {
  format: string;
  data: {
    [key: string]: unknown;
  };
  credential_ids?: Array<string>;
};

export type PresentationConfig = {
  /**
   * Unique identifier for the VP request.
   */
  id: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  /**
   * Description of the presentation configuration.
   */
  description?: string;
  /**
   * Lifetime how long the presentation request is valid after creation, in seconds.
   */
  lifeTime?: number;
  /**
   * The DCQL query to be used for the VP request.
   */
  dcql_query: Dcql;
  /**
   * The registration certificate request containing the necessary details.
   */
  registrationCert?: RegistrationCertificateRequest;
  /**
   * Optional webhook URL to receive the response.
   */
  webhook?: WebhookConfig;
  /**
   * The timestamp when the VP request was created.
   */
  createdAt: string;
  /**
   * The timestamp when the VP request was last updated.
   */
  updatedAt: string;
  /**
   * Attestation that should be attached
   */
  attached?: Array<PresentationAttachment>;
  /**
   * Redirect URI to which the user-agent should be redirected after the presentation is completed.
   * You can use the `{sessionId}` placeholder in the URI, which will be replaced with the actual session ID.
   */
  redirectUri?: string;
  /**
   * Optional ID of the access certificate to use for signing the presentation request.
   * If not provided, the default access certificate for the tenant will be used.
   *
   * Note: This is intentionally NOT a TypeORM relationship because CertEntity uses
   * a composite primary key (id + tenantId), and SQLite cannot create foreign keys
   * that reference only part of a composite primary key. The relationship is handled
   * at the application level in the service layer.
   */
  accessCertId?: string;
};

export type PresentationConfigCreateDto = {
  /**
   * Unique identifier for the VP request.
   */
  id: string;
  /**
   * Description of the presentation configuration.
   */
  description?: string;
  /**
   * Lifetime how long the presentation request is valid after creation, in seconds.
   */
  lifeTime?: number;
  /**
   * The DCQL query to be used for the VP request.
   */
  dcql_query: Dcql;
  /**
   * The registration certificate request containing the necessary details.
   */
  registrationCert?: RegistrationCertificateRequest;
  /**
   * Optional webhook URL to receive the response.
   */
  webhook?: WebhookConfig;
  /**
   * Attestation that should be attached
   */
  attached?: Array<PresentationAttachment>;
  /**
   * Redirect URI to which the user-agent should be redirected after the presentation is completed.
   * You can use the `{sessionId}` placeholder in the URI, which will be replaced with the actual session ID.
   */
  redirectUri?: string;
  /**
   * Optional ID of the access certificate to use for signing the presentation request.
   * If not provided, the default access certificate for the tenant will be used.
   *
   * Note: This is intentionally NOT a TypeORM relationship because CertEntity uses
   * a composite primary key (id + tenantId), and SQLite cannot create foreign keys
   * that reference only part of a composite primary key. The relationship is handled
   * at the application level in the service layer.
   */
  accessCertId?: string;
};

export type PresentationConfigUpdateDto = {
  /**
   * Unique identifier for the VP request.
   */
  id?: string;
  /**
   * Description of the presentation configuration.
   */
  description?: string;
  /**
   * Lifetime how long the presentation request is valid after creation, in seconds.
   */
  lifeTime?: number;
  /**
   * The DCQL query to be used for the VP request.
   */
  dcql_query?: Dcql;
  /**
   * The registration certificate request containing the necessary details.
   */
  registrationCert?: RegistrationCertificateRequest;
  /**
   * Optional webhook URL to receive the response.
   */
  webhook?: WebhookConfig;
  /**
   * Attestation that should be attached
   */
  attached?: Array<PresentationAttachment>;
  /**
   * Redirect URI to which the user-agent should be redirected after the presentation is completed.
   * You can use the `{sessionId}` placeholder in the URI, which will be replaced with the actual session ID.
   */
  redirectUri?: string;
  /**
   * Optional ID of the access certificate to use for signing the presentation request.
   * If not provided, the default access certificate for the tenant will be used.
   *
   * Note: This is intentionally NOT a TypeORM relationship because CertEntity uses
   * a composite primary key (id + tenantId), and SQLite cannot create foreign keys
   * that reference only part of a composite primary key. The relationship is handled
   * at the application level in the service layer.
   */
  accessCertId?: string;
};

export type TrustListCreateDto = {
  certId?: string;
  entities: Array<{
    [key: string]: unknown;
  }>;
  /**
   * Unique identifier for the trust list
   */
  id: string;
  description?: string;
  /**
   * The full trust list JSON (generated LoTE structure)
   */
  data?: {
    [key: string]: unknown;
  };
};

export type TrustList = {
  /**
   * Unique identifier for the trust list
   */
  id: string;
  description?: string;
  /**
   * The tenant ID for which the VP request is made.
   */
  tenantId: string;
  /**
   * The tenant that owns this object.
   */
  tenant: TenantEntity;
  certId: string;
  cert: CertEntity;
  /**
   * The full trust list JSON (generated LoTE structure)
   */
  data?: {
    [key: string]: unknown;
  };
  /**
   * The original entity configuration used to create this trust list.
   * Stored for round-tripping when editing.
   */
  entityConfig?: Array<{
    [key: string]: unknown;
  }>;
  /**
   * The sequence number for versioning (incremented on updates)
   */
  sequenceNumber: number;
  /**
   * The signed JWT representation of this trust list
   */
  jwt: string;
  createdAt: string;
  updatedAt: string;
};

export type TrustListVersion = {
  id: string;
  trustListId: string;
  trustList: TrustList;
  tenantId: string;
  /**
   * The sequence number at the time this version was created
   */
  sequenceNumber: number;
  /**
   * The full trust list JSON at this version
   */
  data: {
    [key: string]: unknown;
  };
  /**
   * The entity configuration at this version
   */
  entityConfig?: {
    [key: string]: unknown;
  };
  /**
   * The signed JWT at this version
   */
  jwt: string;
  createdAt: string;
};

export type PresentationRequest = {
  /**
   * The type of response expected from the presentation request.
   */
  response_type: "qrcode" | "uri" | "dc-api";
  /**
   * Identifier of the presentation configuration
   */
  requestId: string;
  /**
   * Webhook configuration to receive the response.
   * If not provided, the configured webhook from the configuration will be used.
   */
  webhook?: WebhookConfig;
  /**
   * Optional redirect URI to which the user-agent should be redirected after the presentation is completed.
   * You can use the `{sessionId}` placeholder in the URI, which will be replaced with the actual session ID.
   */
  redirectUri?: string;
};

export type FileUploadDto = {
  file: Blob | File;
};

export type AppControllerMainData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/";
};

export type AppControllerMainResponses = {
  200: unknown;
};

export type HealthControllerCheckData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/health";
};

export type HealthControllerCheckErrors = {
  /**
   * The Health Check is not successful
   */
  503: {
    status?: string;
    info?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
    error?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
    details?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
  };
};

export type HealthControllerCheckError =
  HealthControllerCheckErrors[keyof HealthControllerCheckErrors];

export type HealthControllerCheckResponses = {
  /**
   * The Health Check is successful
   */
  200: {
    status?: string;
    info?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
    error?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
    details?: {
      [key: string]: {
        status: string;
        [key: string]: unknown | string;
      };
    };
  };
};

export type HealthControllerCheckResponse =
  HealthControllerCheckResponses[keyof HealthControllerCheckResponses];

export type PrometheusControllerIndexData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/metrics";
};

export type PrometheusControllerIndexResponses = {
  200: unknown;
};

export type AuthControllerGetOAuth2TokenData = {
  body: ClientCredentialsDto;
  path?: never;
  query?: never;
  url: "/oauth2/token";
};

export type AuthControllerGetOAuth2TokenErrors = {
  /**
   * Invalid client credentials
   */
  401: unknown;
};

export type AuthControllerGetOAuth2TokenResponses = {
  /**
   * OAuth2 token response
   */
  200: TokenResponse;
  201: TokenResponse;
};

export type AuthControllerGetOAuth2TokenResponse =
  AuthControllerGetOAuth2TokenResponses[keyof AuthControllerGetOAuth2TokenResponses];

export type AuthControllerGetOidcDiscoveryData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/.well-known/oauth-authorization-server";
};

export type AuthControllerGetOidcDiscoveryResponses = {
  /**
   * OIDC Discovery Configuration
   */
  200: unknown;
};

export type AuthControllerGetGlobalJwksData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/.well-known/jwks.json";
};

export type AuthControllerGetGlobalJwksResponses = {
  /**
   * JSON Web Key Set
   */
  200: unknown;
};

export type TenantControllerGetTenantsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/tenant";
};

export type TenantControllerGetTenantsResponses = {
  200: Array<TenantEntity>;
};

export type TenantControllerGetTenantsResponse =
  TenantControllerGetTenantsResponses[keyof TenantControllerGetTenantsResponses];

export type TenantControllerInitTenantData = {
  body: CreateTenantDto;
  path?: never;
  query?: never;
  url: "/tenant";
};

export type TenantControllerInitTenantResponses = {
  201: unknown;
};

export type TenantControllerDeleteTenantData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/tenant/{id}";
};

export type TenantControllerDeleteTenantResponses = {
  200: unknown;
};

export type TenantControllerGetTenantData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/tenant/{id}";
};

export type TenantControllerGetTenantResponses = {
  200: TenantEntity;
};

export type TenantControllerGetTenantResponse =
  TenantControllerGetTenantResponses[keyof TenantControllerGetTenantResponses];

export type TenantControllerUpdateTenantData = {
  body: UpdateTenantDto;
  path: {
    id: string;
  };
  query?: never;
  url: "/tenant/{id}";
};

export type TenantControllerUpdateTenantResponses = {
  200: TenantEntity;
};

export type TenantControllerUpdateTenantResponse =
  TenantControllerUpdateTenantResponses[keyof TenantControllerUpdateTenantResponses];

export type ClientControllerGetClientsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/client";
};

export type ClientControllerGetClientsResponses = {
  200: Array<ClientEntity>;
};

export type ClientControllerGetClientsResponse =
  ClientControllerGetClientsResponses[keyof ClientControllerGetClientsResponses];

export type ClientControllerCreateClientData = {
  body: CreateClientDto;
  path?: never;
  query?: never;
  url: "/client";
};

export type ClientControllerCreateClientResponses = {
  201: ClientEntity;
};

export type ClientControllerCreateClientResponse =
  ClientControllerCreateClientResponses[keyof ClientControllerCreateClientResponses];

export type ClientControllerDeleteClientData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/client/{id}";
};

export type ClientControllerDeleteClientResponses = {
  200: unknown;
};

export type ClientControllerGetClientData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/client/{id}";
};

export type ClientControllerGetClientResponses = {
  200: ClientEntity;
};

export type ClientControllerGetClientResponse =
  ClientControllerGetClientResponses[keyof ClientControllerGetClientResponses];

export type ClientControllerUpdateClientData = {
  body: UpdateClientDto;
  path: {
    id: string;
  };
  query?: never;
  url: "/client/{id}";
};

export type ClientControllerUpdateClientResponses = {
  200: {
    [key: string]: unknown;
  };
};

export type ClientControllerUpdateClientResponse =
  ClientControllerUpdateClientResponses[keyof ClientControllerUpdateClientResponses];

export type ClientControllerGetClientSecretData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/client/{id}/secret";
};

export type ClientControllerGetClientSecretResponses = {
  200: ClientSecretResponseDto;
};

export type ClientControllerGetClientSecretResponse =
  ClientControllerGetClientSecretResponses[keyof ClientControllerGetClientSecretResponses];

export type KeyControllerGetKeysData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/key";
};

export type KeyControllerGetKeysResponses = {
  200: Array<KeyEntity>;
};

export type KeyControllerGetKeysResponse =
  KeyControllerGetKeysResponses[keyof KeyControllerGetKeysResponses];

export type KeyControllerAddKeyData = {
  body: KeyImportDto;
  path?: never;
  query?: never;
  url: "/key";
};

export type KeyControllerAddKeyResponses = {
  201: unknown;
};

export type KeyControllerDeleteKeyData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/key/{id}";
};

export type KeyControllerDeleteKeyResponses = {
  200: unknown;
};

export type KeyControllerGetKeyData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/key/{id}";
};

export type KeyControllerGetKeyResponses = {
  200: KeyEntity;
};

export type KeyControllerGetKeyResponse =
  KeyControllerGetKeyResponses[keyof KeyControllerGetKeyResponses];

export type KeyControllerUpdateKeyData = {
  body: UpdateKeyDto;
  path: {
    id: string;
  };
  query?: never;
  url: "/key/{id}";
};

export type KeyControllerUpdateKeyResponses = {
  200: unknown;
};

export type CertControllerGetCertificatesData = {
  body?: never;
  path?: never;
  query?: {
    keyId?: string;
  };
  url: "/certs";
};

export type CertControllerGetCertificatesResponses = {
  200: Array<CertEntity>;
};

export type CertControllerGetCertificatesResponse =
  CertControllerGetCertificatesResponses[keyof CertControllerGetCertificatesResponses];

export type CertControllerAddCertificateData = {
  body: CertImportDto;
  path?: never;
  query?: never;
  url: "/certs";
};

export type CertControllerAddCertificateResponses = {
  201: CertResponseDto;
};

export type CertControllerAddCertificateResponse =
  CertControllerAddCertificateResponses[keyof CertControllerAddCertificateResponses];

export type CertControllerDeleteCertificateData = {
  body?: never;
  path: {
    certId: string;
  };
  query?: never;
  url: "/certs/{certId}";
};

export type CertControllerDeleteCertificateResponses = {
  200: unknown;
};

export type CertControllerGetCertificateData = {
  body?: never;
  path: {
    certId: string;
  };
  query?: never;
  url: "/certs/{certId}";
};

export type CertControllerGetCertificateResponses = {
  200: CertEntity;
};

export type CertControllerGetCertificateResponse =
  CertControllerGetCertificateResponses[keyof CertControllerGetCertificateResponses];

export type CertControllerUpdateCertificateData = {
  body: CertUpdateDto;
  path: {
    certId: string;
  };
  query?: never;
  url: "/certs/{certId}";
};

export type CertControllerUpdateCertificateResponses = {
  200: unknown;
};

export type CertControllerExportConfigData = {
  body?: never;
  path: {
    certId: string;
  };
  query?: never;
  url: "/certs/{certId}/config";
};

export type CertControllerExportConfigResponses = {
  200: CertImportDto;
};

export type CertControllerExportConfigResponse =
  CertControllerExportConfigResponses[keyof CertControllerExportConfigResponses];

export type StatusListControllerGetListData = {
  body?: never;
  path: {
    tenantId: string;
    listId: string;
  };
  query?: never;
  url: "/{tenantId}/status-management/status-list/{listId}";
};

export type StatusListControllerGetListResponses = {
  200: string;
};

export type StatusListControllerGetListResponse =
  StatusListControllerGetListResponses[keyof StatusListControllerGetListResponses];

export type StatusListControllerGetStatusListAggregationData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/status-management/status-list-aggregation";
};

export type StatusListControllerGetStatusListAggregationResponses = {
  /**
   * List of status list URIs
   */
  200: StatusListAggregationDto;
};

export type StatusListControllerGetStatusListAggregationResponse =
  StatusListControllerGetStatusListAggregationResponses[keyof StatusListControllerGetStatusListAggregationResponses];

export type StatusListConfigControllerResetConfigData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/status-list-config";
};

export type StatusListConfigControllerResetConfigResponses = {
  /**
   * Configuration reset successfully
   */
  204: void;
};

export type StatusListConfigControllerResetConfigResponse =
  StatusListConfigControllerResetConfigResponses[keyof StatusListConfigControllerResetConfigResponses];

export type StatusListConfigControllerGetConfigData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/status-list-config";
};

export type StatusListConfigControllerGetConfigResponses = {
  /**
   * The status list configuration
   */
  200: StatusListConfig;
};

export type StatusListConfigControllerGetConfigResponse =
  StatusListConfigControllerGetConfigResponses[keyof StatusListConfigControllerGetConfigResponses];

export type StatusListConfigControllerUpdateConfigData = {
  body: UpdateStatusListConfigDto;
  path?: never;
  query?: never;
  url: "/status-list-config";
};

export type StatusListConfigControllerUpdateConfigResponses = {
  /**
   * The updated status list configuration
   */
  200: StatusListConfig;
};

export type StatusListConfigControllerUpdateConfigResponse =
  StatusListConfigControllerUpdateConfigResponses[keyof StatusListConfigControllerUpdateConfigResponses];

export type StatusListManagementControllerGetListsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/status-lists";
};

export type StatusListManagementControllerGetListsResponses = {
  /**
   * List of status lists
   */
  200: Array<StatusListResponseDto>;
};

export type StatusListManagementControllerGetListsResponse =
  StatusListManagementControllerGetListsResponses[keyof StatusListManagementControllerGetListsResponses];

export type StatusListManagementControllerCreateListData = {
  body: CreateStatusListDto;
  path?: never;
  query?: never;
  url: "/status-lists";
};

export type StatusListManagementControllerCreateListResponses = {
  /**
   * The created status list
   */
  201: StatusListResponseDto;
};

export type StatusListManagementControllerCreateListResponse =
  StatusListManagementControllerCreateListResponses[keyof StatusListManagementControllerCreateListResponses];

export type StatusListManagementControllerDeleteListData = {
  body?: never;
  path: {
    /**
     * The status list ID
     */
    listId: string;
  };
  query?: never;
  url: "/status-lists/{listId}";
};

export type StatusListManagementControllerDeleteListResponses = {
  /**
   * Status list deleted successfully
   */
  204: void;
};

export type StatusListManagementControllerDeleteListResponse =
  StatusListManagementControllerDeleteListResponses[keyof StatusListManagementControllerDeleteListResponses];

export type StatusListManagementControllerGetListData = {
  body?: never;
  path: {
    /**
     * The status list ID
     */
    listId: string;
  };
  query?: never;
  url: "/status-lists/{listId}";
};

export type StatusListManagementControllerGetListResponses = {
  /**
   * The status list
   */
  200: StatusListResponseDto;
};

export type StatusListManagementControllerGetListResponse =
  StatusListManagementControllerGetListResponses[keyof StatusListManagementControllerGetListResponses];

export type StatusListManagementControllerUpdateListData = {
  body: UpdateStatusListDto;
  path: {
    /**
     * The status list ID
     */
    listId: string;
  };
  query?: never;
  url: "/status-lists/{listId}";
};

export type StatusListManagementControllerUpdateListResponses = {
  /**
   * The updated status list
   */
  200: StatusListResponseDto;
};

export type StatusListManagementControllerUpdateListResponse =
  StatusListManagementControllerUpdateListResponses[keyof StatusListManagementControllerUpdateListResponses];

export type SessionControllerGetAllSessionsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/session";
};

export type SessionControllerGetAllSessionsResponses = {
  200: Array<Session>;
};

export type SessionControllerGetAllSessionsResponse =
  SessionControllerGetAllSessionsResponses[keyof SessionControllerGetAllSessionsResponses];

export type SessionControllerDeleteSessionData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/session/{id}";
};

export type SessionControllerDeleteSessionResponses = {
  200: unknown;
};

export type SessionControllerGetSessionData = {
  body?: never;
  path: {
    /**
     * The session ID
     */
    id: string;
  };
  query?: never;
  url: "/session/{id}";
};

export type SessionControllerGetSessionResponses = {
  200: Session;
};

export type SessionControllerGetSessionResponse =
  SessionControllerGetSessionResponses[keyof SessionControllerGetSessionResponses];

export type SessionControllerRevokeAllData = {
  body: StatusUpdateDto;
  path?: never;
  query?: never;
  url: "/session/revoke";
};

export type SessionControllerRevokeAllResponses = {
  201: unknown;
};

export type SessionConfigControllerResetConfigData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/session-config";
};

export type SessionConfigControllerResetConfigResponses = {
  /**
   * Configuration reset successfully
   */
  200: unknown;
};

export type SessionConfigControllerGetConfigData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/session-config";
};

export type SessionConfigControllerGetConfigResponses = {
  /**
   * The session storage configuration
   */
  200: SessionStorageConfig;
};

export type SessionConfigControllerGetConfigResponse =
  SessionConfigControllerGetConfigResponses[keyof SessionConfigControllerGetConfigResponses];

export type SessionConfigControllerUpdateConfigData = {
  body: UpdateSessionConfigDto;
  path?: never;
  query?: never;
  url: "/session-config";
};

export type SessionConfigControllerUpdateConfigResponses = {
  /**
   * The updated session storage configuration
   */
  200: SessionStorageConfig;
};

export type SessionConfigControllerUpdateConfigResponse =
  SessionConfigControllerUpdateConfigResponses[keyof SessionConfigControllerUpdateConfigResponses];

export type IssuanceConfigControllerGetIssuanceConfigurationsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/issuer/config";
};

export type IssuanceConfigControllerGetIssuanceConfigurationsResponses = {
  200: IssuanceConfig;
};

export type IssuanceConfigControllerGetIssuanceConfigurationsResponse =
  IssuanceConfigControllerGetIssuanceConfigurationsResponses[keyof IssuanceConfigControllerGetIssuanceConfigurationsResponses];

export type IssuanceConfigControllerStoreIssuanceConfigurationData = {
  body: IssuanceDto;
  path?: never;
  query?: never;
  url: "/issuer/config";
};

export type IssuanceConfigControllerStoreIssuanceConfigurationResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type IssuanceConfigControllerStoreIssuanceConfigurationResponse =
  IssuanceConfigControllerStoreIssuanceConfigurationResponses[keyof IssuanceConfigControllerStoreIssuanceConfigurationResponses];

export type CredentialConfigControllerGetConfigsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/issuer/credentials";
};

export type CredentialConfigControllerGetConfigsResponses = {
  200: Array<CredentialConfig>;
};

export type CredentialConfigControllerGetConfigsResponse =
  CredentialConfigControllerGetConfigsResponses[keyof CredentialConfigControllerGetConfigsResponses];

export type CredentialConfigControllerStoreCredentialConfigurationData = {
  body: CredentialConfigCreate;
  path?: never;
  query?: never;
  url: "/issuer/credentials";
};

export type CredentialConfigControllerStoreCredentialConfigurationResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type CredentialConfigControllerStoreCredentialConfigurationResponse =
  CredentialConfigControllerStoreCredentialConfigurationResponses[keyof CredentialConfigControllerStoreCredentialConfigurationResponses];

export type CredentialConfigControllerDeleteIssuanceConfigurationData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/issuer/credentials/{id}";
};

export type CredentialConfigControllerDeleteIssuanceConfigurationResponses = {
  200: unknown;
};

export type CredentialConfigControllerGetConfigByIdData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/issuer/credentials/{id}";
};

export type CredentialConfigControllerGetConfigByIdResponses = {
  200: CredentialConfig;
};

export type CredentialConfigControllerGetConfigByIdResponse =
  CredentialConfigControllerGetConfigByIdResponses[keyof CredentialConfigControllerGetConfigByIdResponses];

export type CredentialConfigControllerUpdateCredentialConfigurationData = {
  body: CredentialConfigUpdate;
  path: {
    id: string;
  };
  query?: never;
  url: "/issuer/credentials/{id}";
};

export type CredentialConfigControllerUpdateCredentialConfigurationResponses = {
  200: {
    [key: string]: unknown;
  };
};

export type CredentialConfigControllerUpdateCredentialConfigurationResponse =
  CredentialConfigControllerUpdateCredentialConfigurationResponses[keyof CredentialConfigControllerUpdateCredentialConfigurationResponses];

export type Oid4VciControllerCredentialData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/vci/credential";
};

export type Oid4VciControllerCredentialResponses = {
  200: unknown;
};

export type Oid4VciControllerNotificationsData = {
  body: NotificationRequestDto;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/vci/notification";
};

export type Oid4VciControllerNotificationsResponses = {
  201: unknown;
};

export type Oid4VciControllerNonceData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/vci/nonce";
};

export type Oid4VciControllerNonceResponses = {
  200: unknown;
};

export type AuthorizeControllerAuthorizeData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: {
    issuer_state?: string;
    response_type?: string;
    client_id?: string;
    redirect_uri?: string;
    resource?: string;
    scope?: string;
    code_challenge?: string;
    code_challenge_method?: string;
    dpop_jkt?: string;
    request_uri?: string;
    auth_session?: string;
    state?: string;
  };
  url: "/{tenantId}/authorize";
};

export type AuthorizeControllerAuthorizeResponses = {
  200: unknown;
};

export type AuthorizeControllerParData = {
  /**
   * Pushed Authorization Request
   */
  body: AuthorizeQueries;
  path?: never;
  query?: never;
  url: "/{tenantId}/authorize/par";
};

export type AuthorizeControllerParResponses = {
  201: ParResponseDto;
};

export type AuthorizeControllerParResponse =
  AuthorizeControllerParResponses[keyof AuthorizeControllerParResponses];

export type AuthorizeControllerTokenData = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/authorize/token";
};

export type AuthorizeControllerTokenResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type AuthorizeControllerTokenResponse =
  AuthorizeControllerTokenResponses[keyof AuthorizeControllerTokenResponses];

export type AuthorizeControllerAuthorizationChallengeEndpointData = {
  body: AuthorizeQueries;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/authorize/challenge";
};

export type AuthorizeControllerAuthorizationChallengeEndpointResponses = {
  201: unknown;
};

export type CredentialOfferControllerGetOfferData = {
  body: OfferRequestDto;
  path?: never;
  query?: never;
  url: "/issuer/offer";
};

export type CredentialOfferControllerGetOfferResponses = {
  /**
   * JSON response
   */
  201: OfferResponse;
};

export type CredentialOfferControllerGetOfferResponse =
  CredentialOfferControllerGetOfferResponses[keyof CredentialOfferControllerGetOfferResponses];

export type Oid4VciMetadataControllerVctData = {
  body?: never;
  path: {
    id: string;
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/credentials-metadata/vct/{id}";
};

export type Oid4VciMetadataControllerVctResponses = {
  200: Vct;
};

export type Oid4VciMetadataControllerVctResponse =
  Oid4VciMetadataControllerVctResponses[keyof Oid4VciMetadataControllerVctResponses];

export type WellKnownControllerIssuerMetadata0Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/.well-known/openid-credential-issuer/{tenantId}";
};

export type WellKnownControllerIssuerMetadata0Responses = {
  200: {
    [key: string]: unknown;
  };
};

export type WellKnownControllerIssuerMetadata0Response =
  WellKnownControllerIssuerMetadata0Responses[keyof WellKnownControllerIssuerMetadata0Responses];

export type WellKnownControllerIssuerMetadata1Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/.well-known/openid-credential-issuer";
};

export type WellKnownControllerIssuerMetadata1Responses = {
  200: {
    [key: string]: unknown;
  };
};

export type WellKnownControllerIssuerMetadata1Response =
  WellKnownControllerIssuerMetadata1Responses[keyof WellKnownControllerIssuerMetadata1Responses];

export type WellKnownControllerAuthzMetadata0Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/.well-known/oauth-authorization-server/{tenantId}";
};

export type WellKnownControllerAuthzMetadata0Responses = {
  200: unknown;
};

export type WellKnownControllerAuthzMetadata1Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/.well-known/oauth-authorization-server";
};

export type WellKnownControllerAuthzMetadata1Responses = {
  200: unknown;
};

export type WellKnownControllerGetJwks0Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/.well-known/jwks.json/{tenantId}";
};

export type WellKnownControllerGetJwks0Responses = {
  200: JwksResponseDto;
};

export type WellKnownControllerGetJwks0Response =
  WellKnownControllerGetJwks0Responses[keyof WellKnownControllerGetJwks0Responses];

export type WellKnownControllerGetJwks1Data = {
  body?: never;
  path: {
    tenantId: string;
  };
  query?: never;
  url: "/{tenantId}/.well-known/jwks.json";
};

export type WellKnownControllerGetJwks1Responses = {
  200: JwksResponseDto;
};

export type WellKnownControllerGetJwks1Response =
  WellKnownControllerGetJwks1Responses[keyof WellKnownControllerGetJwks1Responses];

export type Oid4VpControllerGetRequestWithSessionData = {
  body?: never;
  path: {
    session: string;
  };
  query?: never;
  url: "/{session}/oid4vp/request";
};

export type Oid4VpControllerGetRequestWithSessionResponses = {
  200: string;
};

export type Oid4VpControllerGetRequestWithSessionResponse =
  Oid4VpControllerGetRequestWithSessionResponses[keyof Oid4VpControllerGetRequestWithSessionResponses];

export type Oid4VpControllerGetPostRequestWithSessionData = {
  body?: never;
  path: {
    session: string;
  };
  query?: never;
  url: "/{session}/oid4vp/request";
};

export type Oid4VpControllerGetPostRequestWithSessionResponses = {
  201: string;
};

export type Oid4VpControllerGetPostRequestWithSessionResponse =
  Oid4VpControllerGetPostRequestWithSessionResponses[keyof Oid4VpControllerGetPostRequestWithSessionResponses];

export type Oid4VpControllerGetResponseData = {
  body: AuthorizationResponse;
  path: {
    session: string;
  };
  query?: never;
  url: "/{session}/oid4vp";
};

export type Oid4VpControllerGetResponseResponses = {
  200: {
    [key: string]: unknown;
  };
};

export type Oid4VpControllerGetResponseResponse =
  Oid4VpControllerGetResponseResponses[keyof Oid4VpControllerGetResponseResponses];

export type PresentationManagementControllerConfigurationData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/verifier/config";
};

export type PresentationManagementControllerConfigurationResponses = {
  200: Array<PresentationConfig>;
};

export type PresentationManagementControllerConfigurationResponse =
  PresentationManagementControllerConfigurationResponses[keyof PresentationManagementControllerConfigurationResponses];

export type PresentationManagementControllerStorePresentationConfigData = {
  body: PresentationConfigCreateDto;
  path?: never;
  query?: never;
  url: "/verifier/config";
};

export type PresentationManagementControllerStorePresentationConfigResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type PresentationManagementControllerStorePresentationConfigResponse =
  PresentationManagementControllerStorePresentationConfigResponses[keyof PresentationManagementControllerStorePresentationConfigResponses];

export type PresentationManagementControllerDeleteConfigurationData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/verifier/config/{id}";
};

export type PresentationManagementControllerDeleteConfigurationResponses = {
  200: unknown;
};

export type PresentationManagementControllerGetConfigurationData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/verifier/config/{id}";
};

export type PresentationManagementControllerGetConfigurationResponses = {
  200: PresentationConfig;
};

export type PresentationManagementControllerGetConfigurationResponse =
  PresentationManagementControllerGetConfigurationResponses[keyof PresentationManagementControllerGetConfigurationResponses];

export type PresentationManagementControllerUpdateConfigurationData = {
  body: PresentationConfigUpdateDto;
  path: {
    id: string;
  };
  query?: never;
  url: "/verifier/config/{id}";
};

export type PresentationManagementControllerUpdateConfigurationResponses = {
  200: {
    [key: string]: unknown;
  };
};

export type PresentationManagementControllerUpdateConfigurationResponse =
  PresentationManagementControllerUpdateConfigurationResponses[keyof PresentationManagementControllerUpdateConfigurationResponses];

export type TrustListControllerGetAllTrustListsData = {
  body?: never;
  path?: never;
  query?: never;
  url: "/trust-list";
};

export type TrustListControllerGetAllTrustListsResponses = {
  200: Array<TrustList>;
};

export type TrustListControllerGetAllTrustListsResponse =
  TrustListControllerGetAllTrustListsResponses[keyof TrustListControllerGetAllTrustListsResponses];

export type TrustListControllerCreateTrustListData = {
  body: TrustListCreateDto;
  path?: never;
  query?: never;
  url: "/trust-list";
};

export type TrustListControllerCreateTrustListResponses = {
  201: TrustList;
};

export type TrustListControllerCreateTrustListResponse =
  TrustListControllerCreateTrustListResponses[keyof TrustListControllerCreateTrustListResponses];

export type TrustListControllerDeleteTrustListData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/trust-list/{id}";
};

export type TrustListControllerDeleteTrustListResponses = {
  200: unknown;
};

export type TrustListControllerGetTrustListData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/trust-list/{id}";
};

export type TrustListControllerGetTrustListResponses = {
  200: TrustList;
};

export type TrustListControllerGetTrustListResponse =
  TrustListControllerGetTrustListResponses[keyof TrustListControllerGetTrustListResponses];

export type TrustListControllerUpdateTrustListData = {
  body: TrustListCreateDto;
  path: {
    id: string;
  };
  query?: never;
  url: "/trust-list/{id}";
};

export type TrustListControllerUpdateTrustListResponses = {
  200: TrustList;
};

export type TrustListControllerUpdateTrustListResponse =
  TrustListControllerUpdateTrustListResponses[keyof TrustListControllerUpdateTrustListResponses];

export type TrustListControllerExportTrustListData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/trust-list/{id}/export";
};

export type TrustListControllerExportTrustListResponses = {
  200: TrustListCreateDto;
};

export type TrustListControllerExportTrustListResponse =
  TrustListControllerExportTrustListResponses[keyof TrustListControllerExportTrustListResponses];

export type TrustListControllerGetTrustListVersionsData = {
  body?: never;
  path: {
    id: string;
  };
  query?: never;
  url: "/trust-list/{id}/versions";
};

export type TrustListControllerGetTrustListVersionsResponses = {
  200: Array<TrustListVersion>;
};

export type TrustListControllerGetTrustListVersionsResponse =
  TrustListControllerGetTrustListVersionsResponses[keyof TrustListControllerGetTrustListVersionsResponses];

export type TrustListControllerGetTrustListVersionData = {
  body?: never;
  path: {
    id: string;
    versionId: string;
  };
  query?: never;
  url: "/trust-list/{id}/versions/{versionId}";
};

export type TrustListControllerGetTrustListVersionResponses = {
  200: TrustListVersion;
};

export type TrustListControllerGetTrustListVersionResponse =
  TrustListControllerGetTrustListVersionResponses[keyof TrustListControllerGetTrustListVersionResponses];

export type TrustListPublicControllerGetTrustListJwtData = {
  body?: never;
  path: {
    tenantId: string;
    id: string;
  };
  query?: never;
  url: "/{tenantId}/trust-list/{id}";
};

export type TrustListPublicControllerGetTrustListJwtResponses = {
  200: string;
};

export type TrustListPublicControllerGetTrustListJwtResponse =
  TrustListPublicControllerGetTrustListJwtResponses[keyof TrustListPublicControllerGetTrustListJwtResponses];

export type VerifierOfferControllerGetOfferData = {
  body: PresentationRequest;
  path?: never;
  query?: never;
  url: "/verifier/offer";
};

export type VerifierOfferControllerGetOfferResponses = {
  /**
   * JSON response
   */
  201: OfferResponse;
};

export type VerifierOfferControllerGetOfferResponse =
  VerifierOfferControllerGetOfferResponses[keyof VerifierOfferControllerGetOfferResponses];

export type StorageControllerUploadData = {
  /**
   * List of cats
   */
  body: FileUploadDto;
  path?: never;
  query?: never;
  url: "/storage";
};

export type StorageControllerUploadResponses = {
  201: {
    [key: string]: unknown;
  };
};

export type StorageControllerUploadResponse =
  StorageControllerUploadResponses[keyof StorageControllerUploadResponses];

export type StorageControllerDownloadData = {
  body?: never;
  path: {
    key: string;
  };
  query?: never;
  url: "/storage/{key}";
};

export type StorageControllerDownloadResponses = {
  200: unknown;
};
